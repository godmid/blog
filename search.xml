<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>c/c++ long int与long long的区别</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      
        <content type="html"><![CDATA[<center>   </center><h1 id="long-int"><a href="#long-int" class="headerlink" title="long int"></a>long int</h1><p>　　long int即long，给人的感觉好像是长整型，但实际上，它和int一样，只有32位。cppreference给出的定义是——</p><blockquote><p><strong>int</strong> - basic integer type. The keyword int may be omitted if any of the modifiers listed below are used. If no length modifiers are present, it’s guaranteed to have a width of at least 16 bits. However, on 32/64 bit systems it is almost exclusively guaranteed to have width of at least 32 bits.<br><strong>long</strong> - target type will have width of at least 32 bits.</p></blockquote><p>　　在实际的使用中，long与int几乎没有区别，比如——</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">long</span> l <span class="token operator">=</span> <span class="token number">10000000</span><span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10000000</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"size of long:%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"size of int:%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"l = %d\n"</span><span class="token punctuation">,</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i = %d\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">1234567891011</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/2018122510141490.png"><br>　　既然long int与int相同，那么为什么还有long int这种尴尬的类型呢？<br>　　原因是早期的C编译器定义了long int占用4个字节，int占用2个字节，long int是名副其实的<strong>长整型</strong>。在ANSI C的标准中，对长整型的定义也是<strong>long int应该至少和int一样长</strong>，而不是long int 一定要比int占用存储字节长。新版的C/C++标准兼容了早期的这一设定。</p><span id="more"></span><h1 id="long-long"><a href="#long-long" class="headerlink" title="long long"></a>long long</h1><p>　　long long则不同，long long是C++的64位整型的基本类型，“现任”长整型，从C99开始引入这个概念，在后续的标准中完善概念和定义，C++11官方正式标准如下——</p><blockquote><p><strong>long long</strong> - target type will have width of at least 64 bits.(since C++11)</p></blockquote><p>　　long long占用8个字节，数据表示范围也从int的[ − 2 31 , 2 31 − 1 ] [-2^{31},2^{31}-1][−231,231−1]，升级到[ − 2 63 , 2 63 − 1 ] [-2^{63},2^{63}-1][−263,263−1]。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">long</span> l <span class="token operator">=</span> <span class="token number">10000000</span><span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10000000</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> ll <span class="token operator">=</span> <span class="token number">100000000000000</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"size of long:%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"size of int:%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"size of long long:%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"l = %d\n"</span><span class="token punctuation">,</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i = %d\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ll = %lld\n"</span><span class="token punctuation">,</span>ll<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">1234567891011121314</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20181225103911667.png"><br>　　long long是C++的正式标准，这也就意味着，该类型不会因为编译器或者开发平台的不同而有所差异，放之四海而皆准，而且与一些系统函数、类库都有很好的交互（如常见的printf、scanf、cin和cout等)。与之相反，出身MS的__int64就有点不受待见了，在不同的编译器上可能水土不服。</p><h1 id="int64"><a href="#int64" class="headerlink" title="__int64"></a>__int64</h1><p>　　在早期的代码中，可能会遇到<code>__int64</code>这种类型，这应该算是“历史遗留”问题。早期的C/C++标准中并没有规定64位长整型的规范，因此不同的编译器对这一模糊概念有不同的定义，我们熟知的VC6.0采用了<code>__int64</code>这种类型来表示64位长整型——</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cmath&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>__int64 i64 <span class="token operator">=</span> <span class="token operator">-</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">63</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"__int64:"</span><span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>__int64<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> cout<span class="token operator">&lt;&lt;</span><span class="token string">"i64 = "</span><span class="token operator">&lt;&lt;</span>i64<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">123456789</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20181225104812530.png"><br>　　与long long具有相同的效果，但是，__int64并不是正式规范，比如，如果你使用的是MinGW的编译器的话，打开__int64的定义会发现——<br><img src="https://img-blog.csdnimg.cn/20181225105553149.png"><br>　　VS 2017虽然把__int64作为了一种内置类型，但是也做了类似的处理，使得__int64与long long没有肉眼可见的差别。但如果你使用的开发环境比较早期，那么可能就要专门研究一下__int64了。比如说，古老的VC6.0并没有long long这种类型，而__int64的输入输出，又需要printf和%I64d的配合，而不是%lld或者直接用cout。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>　　C/C++与Java等语言不同，具有较高的自由度，由于某些历史原因，某些概念在不同的平台上有不同的解释，虽然现在新版本的C++标准和编译器都在做兼容性工作，你可以在__int64与long long之间无缝切换，但至少，我们要清楚两者的不同。</p><table><thead><tr><th>类型</th><th>存储字节</th><th>表示范围</th></tr></thead><tbody><tr><td>int</td><td>4</td><td>-2147483648~2147483647</td></tr><tr><td>short int</td><td>2</td><td>-32768～+32767</td></tr><tr><td>long</td><td>4</td><td>-2147483648~2147483647（二十亿，约1 0 10 10^{10}1010）</td></tr><tr><td>long long</td><td>8</td><td>9223372036854775808～+9223372036854775807(九百亿亿，约1 0 19 10^{19}1019)</td></tr><tr><td>__int64</td><td>8</td><td>9223372036854775808～+9223372036854775807</td></tr></tbody></table><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>1.<a href="https://blog.csdn.net/qq_31736627/article/details/52912691">https://blog.csdn.net/qq_31736627/article/details/52912691</a><br>2.<a href="https://en.cppreference.com/w/cpp/language/types">https://en.cppreference.com/w/cpp/language/types</a><br>3.<a href="https://www.cnblogs.com/ChenDinghao/p/6480937.html">https://www.cnblogs.com/ChenDinghao/p/6480937.html</a><br>4.<a href="https://blog.csdn.net/sk18192449347/article/details/55000087">https://blog.csdn.net/sk18192449347/article/details/55000087</a></p>]]></content>
      
      
      <categories>
          
          <category> c语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>太阳能板向阳自校准</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      
        <content type="html"><![CDATA[<center>   </center><span id="more"></span><h4 id="太阳能自动追踪器"><a href="#太阳能自动追踪器" class="headerlink" title="太阳能自动追踪器"></a>太阳能自动追踪器</h4><p>这个也挺新颖，只是这个玩意有简单的现成的了；我在想可不可以用复杂点的低功耗单片机做出来，准确度更高，耗能更少（虽然没啥）</p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210820183455.png"><p>这个玩意的构造很简单，红色面是两个太阳能板；如图</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210820183619.png"><br>然后底座和支撑是一个3d打印的小座子，中间打胶固定了一个电机。<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210820183756.png"><br>这种电机也挺常见的倒也没啥；<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210820183811.png"><em>电机</em><br>原理也挺简单，就是简单的太阳能板连接到了电机上面，有电就转；</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210820190732.png"><br>然后这种电机叫做直流电机，只是带了个减速器，简单理解为用来加大扭力的装置。这种电机正接就正转，反接就反转；然后两个太阳能板反着接，就可以在两边电压相同时停下；<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210820190755.png" alt="成品"></p>]]></content>
      
      
      <categories>
          
          <category> 电子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线音频发射器（简易）</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      
        <content type="html"><![CDATA[<center>   </center><span id="more"></span><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这个小实验是我模仿油管中的一个小玩意做的（可惜实物已经被我拆了），所以大伙权当开开眼了。</p><p>大致长这个模样<strong>↓</strong></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210807173829.png"></p><p><a href="https://www.bilibili.com/video/BV1cX4y1G7Jc">原视频链接</a></p><p>感兴趣的可以去康康</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210807171627.png" alt="原理图"></p><p>其实这个小实验的原理也很简单，但是也有难点，难点都在那个三极管上面其他的倒是没啥</p><p>可惜我没时间讲述三极管的基本原理，在此借别人的光照亮一下。</p><p><a href="https://www.bilibili.com/video/BV1Fx411D71n">三极管动画演示</a></p><p><a href="https://www.bilibili.com/video/BV1kv411574Y">三极管原理</a></p><p>在此只需要知道三极管是一个用于信号放大的器件就可以了（改天没事了我亲自讲述一下三极管的原理）。用三极管组成一个共射放大电路，并使其工作在它的放大区，然后放大了咪头（麦克风）或者其他声源产生的电信号(<a href="https://www.bilibili.com/video/BV1sK4y1n79k">麦克风原理</a>)。之后这个信号作用在激光管上（工作电压看型号而定），就可以产生和声信号对应的光亮变化。你也可以不用麦克风，改用一根音频线（就是你的耳机线，只不过是只使用单声道）。如果使用麦克风的话，麦克风必须是有源的（用于上面那个电路的话）。</p><p>而其他的元器件，类如电阻、电容、开关（开关就不用说了吧）,电阻是用来限流的，电容的话，看下面这个视频你就会有个大致的了解了。</p><p><a href="https://www.bilibili.com/video/BV1mK4y1f7DQ">电容作用</a></p><p>基本原理大致就这样，就是用激光发出去你的声信号，或者说把你的声信号加载到光信号上面。</p><p>我们再来康康<strong>接收端</strong></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210807174025.png" alt="太阳能板"></p><p>接收端是一个太阳能板（头一次见用这个当接受器的），太阳能板可以将光信号转化成电信号（相当于一个解码器），然后我们只需要放大这个信号就可以了。只是这个信号放大的倍数较大，建议用个成品，类似于音响之类的，或者你可以用个功放（全损音质警告）。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210807174453.png"></p><p>然后就可以听到传输出去的声音了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>之前我把它做出来了，然后写文前感觉没啥用被我给拆了（淦）；</p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210807175812.jpg" style="zoom:67%;"><p>如图所示，被我拆下来后的模块。蓝色的是功放，带个咪头的是麦克，黑的那个是激光管，全部被做成模块化</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>传输距离远，电路简单，造价便宜（一共花不了十块钱）</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>干扰多，户外受天气影响较大，户内也受灯光影响，音质感人，不可调参</p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>如果使用的是有源麦克风，那么只需要做出来两个就可以实现远距离通话了，具体距离看你的激光源有多nb吧。原理上来讲是可以无线远的（因为卫星也有类似的通讯模式）。二十块钱做个对讲机，岂不美哉！</p><p>本次分享就到这了，以后有时间再(￣_,￣ )补写上我自己做的成品。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>电机驱动模块-TB6612FNG</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      
        <content type="html"><![CDATA[<center>   </center><span id="more"></span><p>TB6612的用法<br>双驱动，也就是可以驱动两个电机。<br>STBY:接单片机的IO口，清零，电机全部停止。<br>置1，通过AIN1 AIN2,BIN1,BIN2来控制正反转<br>VM 接12V电源<br>VCC 接5V电源<br>GND 接地</p><p>驱动1路<br>PWMA 接单片机的PWM口<br>TB6612FNG每通道输出最高<strong>1A</strong>的连续驱动电流，启动峰值电流达2A／3A(连续脉冲／单脉冲)；4种电机控制模式：正转／反转／制动／停止；<strong>PWM支持频率高达100 kHz</strong>；待机状态；片内低压检测电路与热停机保护电路；工作温度：-20～85℃；SSOP24小型贴片封装。<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20170715172312975" alt="这里写图片描述"><br>[刹车和自由停车有什么区别]</p><p><strong>刹车耗能，自由停车不耗能。刹车耗能来源于刹车片摩擦和电机制动，自由停车相当于断电。</strong><em>冥狐注</em></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/image-20210731211614943.png" alt="image-20210731211614943"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20170715172500813" alt="接法"></p><p><strong>TB6612FNG的主要引脚功能：</strong><br>(1)<strong>AINl／AIN2、BIN1／BIN2、PWMA／PWMB为控制信号输入端；</strong><br>(2)<strong>AO1／A02、B01／B02为2路电机控制输出端；</strong><br>(3)<strong>STBY为正常工作／待机状态控制引脚；</strong><br>(4)<strong>VM(3～13.5 V)和VCC(2．7～5．5 V)分别为电机驱动电压输入和逻辑电平输入端。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 电子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陀螺仪基本原理</title>
      <link href="/posts/611f9591/"/>
      <url>/posts/611f9591/</url>
      
        <content type="html"><![CDATA[<center>   </center><span id="more"></span><p>本帖翻译自 <a href="http://www.starlino.com/imu_guide.html">IMU（加速度计和陀螺仪设备）在嵌入式应用中使用的指南。</a><br>这篇文章主要介绍加速度计和陀螺仪的数学模型和基本算法，以及如何融合这两者，侧重算法、思想的讨论</p><p>介绍<br>本指南旨在向兴趣者介绍惯性MEMS（微机电系统）传感器，特别是加速度计和陀螺仪以及其他整合IMU（ <a href="http://en.wikipedia.org/wiki/Inertial_measurement_unit">惯性测量单元</a>）设备。<br><img src="http://image.geek-workshop.com/forum/201208/22/163854b9769h9p7kvq7omh.jpg"></p><p>2012-8-22 16:38 上传</p><p><a href="http://blog.csdn.net/zhuanghe_xing/article/details/forum.php?mod=attachment&amp;aid=NjQxM3xhNDgxYjAxZnwxMzQ2NTg2MjYwfDMxOTV8MTY5NQ==&amp;nothumb=yes"><strong>下载附件</strong>(16.48 KB)</a></p><p>IMU单元例子：上图中MCU顶端的 <a href="http://www.starlino.com/store/acc-gyro">ACC Gyro 6DOF</a>，名为 <a href="http://www.gadgetgangster.com/find-a-project/56?projectnum=240">USBThumb</a>，支持USB/串口通信</p><p>在这篇文章中我将概括这么几个基本并且重要的话题：<br>- 加速度计（accelerometer）检测什么<br>- 陀螺仪（gyroscope，也称作 gyro）检测什么<br>- 如何将传感器ADC读取的数据转换为物理单位（加速度传感器的单位是g，陀螺仪的单位是 度/秒）<br>- 如何结合加速度传感器和陀螺仪的数据以得到设备和地平面之间的倾角的准确信息<br>在整篇文章中我尽量将数学运算降低到最少。如果你知道什么是正弦、余弦、正切函数，那无论你的项目使用哪种平台你应该都会明白和运用这篇文章中的思想，这些平台如Arduino、Propeller、Basic Stamp、Ateml芯片、PIC芯片等等。总有些人认为使用IMU单元需要复杂的数学运算（复杂的FIR或IIR滤波，如卡尔曼滤波，Parks-McClellan滤波等）。你如果研究这些会得到很棒且很复杂的结果。我解释事情的方式，只需要基本的数学。我非常坚信简单的原则。我认为一个简单的系统更容易操作和监控，另外许多嵌入式设备并不具备能力和资源去实现需要进行矩阵运算的复杂算法。<br>我会用我设计的一个新IMU模块—— <a href="http://www.starlino.com/store/acc-gyro">Acc_Gyro Accelerometer + Gyro IMU</a>作为例子。在下面的例子中我们会使用这个设备的参数。用这个模块作为介绍非常合适，因为它由3个设备组成：<br>- LIS331AL ( <a href="http://www.starlino.com/wp-content/uploads/data/acc_gyro/LIS331AL.pdf">datasheet</a>) – 3轴 2G 模拟加速度计<br>- LPR550AL ( <a href="http://www.starlino.com/wp-content/uploads/data/acc_gyro/LPR550AL.pdf">datasheet</a>) – 双轴（俯仰、翻滚） 500°/s 加速度传感器<br>- LY550ALH ( <a href="http://www.starlino.com/wp-content/uploads/data/acc_gyro/LY550ALH.pdf">datasheet</a>) –单轴（偏航）陀螺仪 最后这个设备在这篇介绍中不使用，不过他在 <a href="http://www.starlino.com/dcm_tutorial.html">DCM Matrix implementation</a>中有重要作用<br>它们一起组成了一个6自由度的惯性测量单元。这是个花哨的名字！然而，在花哨的名字后面是个非常有用的设备组合，接下来我们会详细介绍之。<br>第一部分 加速度计<br>要了解这个模块我们先从加速度计开始。当我们在想象一个加速度计的时候我们可以把它想作一个圆球在一个方盒子中。你可能会把它想作一个饼干或者甜圈，但我就把它当做一个球好了：<br><img src="http://image.geek-workshop.com/forum/201208/22/163855d7e99tne77u81b12.png"></p><p>2012-8-22 16:38 上传</p><p><a href="http://blog.csdn.net/zhuanghe_xing/article/details/forum.php?mod=attachment&amp;aid=NjQxNHw0ZDkxOTU3NXwxMzQ2NTg2MjYwfDMxOTV8MTY5NQ==&amp;nothumb=yes"><strong>下载附件</strong>(15.85 KB)</a></p><p>我们假定这个盒子不在重力场中或者其他任何会影响球的位置的场中，球处于盒子的正中央。你可以想象盒子在外太空中，远离任何天体，如果很难想象，那就当做盒子在航天飞机中，一切东西都处于无重力状态。在上面的图中你可以看到我们给每个轴分配了一对墙（我们移除了Y+以此来观察里面的情况）。设想每面墙都能感测压力。如果我们突然把盒子向左移动（加速度为1g=9.8m/s^2），那么球会撞上X-墙。然后我们检测球撞击墙面产生的压力，X轴输出值为-1g。<br><img src="http://image.geek-workshop.com/forum/201208/22/163856r6orns2rocpzz5sp.png"></p><p>2012-8-22 16:38 上传</p><p><a href="http://blog.csdn.net/zhuanghe_xing/article/details/forum.php?mod=attachment&amp;aid=NjQxNXwxM2U2NjRkZXwxMzQ2NTg2MjYwfDMxOTV8MTY5NQ==&amp;nothumb=yes"><strong>下载附件</strong>(19.23 KB)</a></p><p>请注意加速度计检测到得力的方向与它本身加速度的方向是相反的。这种力量通常被称为 <a href="http://en.wikipedia.org/wiki/Fictitious_force">惯性力或假想力</a> 。在这个模型中你你应该学到加速度计是通过间接测量力对一个墙面的作用来测量加速度的，在实际应用中，可能通过弹簧等装置来测量力。这个力可以是加速度引起的，但在下面的例子中，我们会发现它不一定是加速度引起的。<br>如果我们把模型放在地球上，球会落在Z-墙面上并对其施加一个1g的力，见下图：<br><img src="http://image.geek-workshop.com/forum/201208/22/163856lxjiqd8xlvzh775b.png"></p><p>2012-8-22 16:38 上传</p><p><a href="http://blog.csdn.net/zhuanghe_xing/article/details/forum.php?mod=attachment&amp;aid=NjQxNnxjNGIzNDM1YnwxMzQ2NTg2MjYwfDMxOTV8MTY5NQ==&amp;nothumb=yes"><strong>下载附件</strong>(19.54 KB)</a></p><p>在这种情况下盒子没有移动但我们任然读取到Z轴有-1g的值。球在墙壁上施加的压力是由引力造成的。在理论上，它可以是不同类型的力量 - 例如，你可以想象我们的球是铁质的，将一个磁铁放在盒子旁边那球就会撞上另一面墙。引用这个例子只是为了说明加速度计的本质是检测力而非加速度。只是加速度所引起的惯性力正好能被加速度计的检测装置所捕获。<br>虽然这个模型并非一个MEMS传感器的真实构造，但它用来解决与加速度计相关的问题相当有效。实际上有些类似传感器中有金属小球，它们称作倾角开关，但是它们的功能更弱，只能检测设备是否在一定程度内倾斜，却不能得到倾斜的程度。<br>到目前为止，我们已经分析了单轴的加速度计输出，这是使用单轴加速度计所能得到的。三轴加速度计的真正价值在于它们能够检测全部三个轴的惯性力。让我们回到盒子模型，并将盒子向右旋转45度。现在球会与两个面接触：Z-和X-，见下图：<br><img src="http://image.geek-workshop.com/forum/201208/22/163857bferffolflo9ly9l.png"></p><p>2012-8-22 16:38 上传</p><p><a href="http://blog.csdn.net/zhuanghe_xing/article/details/forum.php?mod=attachment&amp;aid=NjQxN3w1ZGVjODFhOXwxMzQ2NTg2MjYwfDMxOTV8MTY5NQ==&amp;nothumb=yes"><strong>下载附件</strong>(34.03 KB)</a></p><p>0.71g这个值是不是任意的，它们实际上是1/2的平方根的近似值。我们介绍加速度计的下一个模型时这一点会更清楚。<br>在上一个模型中我们引入了重力并旋转了盒子。在最后的两个例子中我们分析了盒子在两种情况下的输出值，力矢量保持不变。虽然这有助于理解加速度计是怎么和外部力相互作用的，但如果我们将坐标系换为加速度的三个轴并想象矢量力在周围旋转，这会更方便计算。<br><img src="http://image.geek-workshop.com/forum/201208/22/163858sssxmnssijjjczf3.png"></p><p>2012-8-22 16:38 上传</p><p><a href="http://blog.csdn.net/zhuanghe_xing/article/details/forum.php?mod=attachment&amp;aid=NjQxOHxjNDNlNzY5Y3wxMzQ2NTg2MjYwfDMxOTV8MTY5NQ==&amp;nothumb=yes"><strong>下载附件</strong>(7.19 KB)</a></p><p>请看看在上面的模型，我保留了轴的颜色，以便你的思维能更好的从上一个模型转到新的模型中。想象新模型中每个轴都分别垂直于原模型中各自的墙面。矢量R是加速度计所检测的矢量（它可能是重力或上面例子中惯性力的合成）。RX，RY，RZ是矢量R在X，Y，Z上的投影。请注意下列关系：<br>，R ^ 2 = RX ^ 2 + RY ^ 2 + RZ ^ 2（ 公式1）<br>此公式等价于 <a href="http://demonstrations.wolfram.com/PythagoreanTheorem3D/">三维空间勾股定理</a>。<br>还记得我刚才说的1/2的平方根0.71不是个随机值吧。如果你把它们代回上式，回顾一下重力加速度是1g，那我们就能验证：<br>1 ^ 2 =（SQRT（1/2））^ 2 + 0 ^ 2 +（SQRT（1/2））^ 2<br>在 公式1中简单的取代： R=1, Rx = -SQRT(1/2), Ry = 0 , Rz = -SQRT(1/2)<br>经过一大段的理论序言后，我们和实际的加速度计很靠近了。RX，RY，RZ值是实际中加速度计输出的线性相关值，你可以用它们进行各种计算。<br>在我们运用它之前我们先讨论一点获取加速度计数据的方法。大多数加速度计可归为两类：数字和模拟。数字加速度计可通过I2C，SPI或USART方式获取信息，而模拟加速度计的输出是一个在预定范围内的电压值，你需要用ADC（模拟量转数字量）模块将其转换为数字值。我将不会详细介绍ADC是怎么工作的，部分原因是这是个很广的话题，另一个原因是不同平台的ADC都会有差别。有些MCU具有内置ADC模块，而有些则需要外部电路进行ADC转换。不管使用什么类型的ADC模块，你都会得到一个在一定范围内的数值。例如一个10位ADC模块的输出值范围在0 .. 1023间，请注意，1023 = 2 ^ 10 -1。一个12位ADC模块的输出值范围在0 .. 4095内，注意，4095 = 2 ^ 12-1。<br>我们继续，先考虑下一个简单的例子，假设我们从10位ADC模块得到了以下的三个轴的数据：<br>AdcRx = 586<br>AdcRy = 630<br>AdcRz = 561<br>每个ADC模块都有一个参考电压，假设在我们的例子中，它是3.3V。要将一个10位的ADC值转成电压值，我们使用下列公式：<br>VoltsRx = AdcRx * VREF / 1023<br>小注：8位ADC的最大值是255 = 2 ^ 8 -1，12位ADC最大值是4095 = 2 ^ 12 -1。<br>将3个轴的值代入上式，得到：<br>VoltsRx = 586 * 3.3 / 1023 =～1.89V（结果取两位小数）<br>VoltsRy = 630 * 3.3 / 1023 =～2.03V<br>VoltsRz = 561 * 3.3 / 1023 =～1.81V<br>每个加速度计都有一个零加速度的电压值，你可以在它的说明书中找到，这个电压值对应于加速度为0g。通过计算相对0g电压的偏移量我们可以得到一个有符号的电压值。比方说，0g电压值 VzeroG= 1.65V，通过下面的方式可以得到相对0g电压的偏移量:<br>DeltaVoltsRx = 1.89V - 1.65V = 0.24V<br>DeltaVoltsRy = 2.03V - 1.65V = 0.38V<br>DeltaVoltsRz = 1.81V - 1.65V = 0.16V<br>现在我们得到了加速度计的电压值，但它的单位还不是g（9.8m/s^2），最后的转换，我们还需要引入加速度计的灵敏度（Sensitivity），单位通常是 mV/g。比方说，加速度计的灵敏度 Sensitivity= 478.5mV / g = 0.4785V /g。灵敏度值可以在加速度计说明书中找到。要获得最后的单位为g的加速度，我们使用下列公式计算：<br>RX = DeltaVoltsRx /Sensitivity<br>RX = 0.24V / 0.4785V / G =～0.5g<br>RY = 0.38V / 0.4785V / G =～0.79g<br>RZ = 0.16V / 0.4785V / G =～0.33g<br>当然，我们可以把所有的步骤全部放在一个式子里，但我想通过介绍每一个步骤以便让你了解怎么读取一个ADC值并将其转换为单位为g的矢量力的分量。<br>Rx = (AdcRx * Vref / 1023 – VzeroG) / Sensitivity (公式2)<br>Ry = (AdcRy * Vref / 1023 – VzeroG) / Sensitivity<br>Rz = (AdcRz * Vref / 1023 – VzeroG) / Sensitivity<br>现在我们得到了惯性力矢量的三个分量，如果设备除了重力外不受任何外力影响，那我们就可以认为这个方向就是重力矢量的方向。如果你想计算设备相对于地面的倾角，可以计算这个矢量和Z轴之间的夹角。如果你对每个轴的倾角都感兴趣，你可以把这个结果分为两个分量：X轴、Y轴倾角，这可以通过计算重力矢量和X、Y轴的夹角得到。计算这些角度比你想象的简单，现在我们已经算出了Rx，Ry，Rz的值，让我们回到我们的上一个加速度模型，再加一些标注上去：<br><img src="http://image.geek-workshop.com/forum/201208/22/1638594bjbb147i1lqb7cz.png"></p><p>2012-8-22 16:38 上传</p><p><a href="http://blog.csdn.net/zhuanghe_xing/article/details/forum.php?mod=attachment&amp;aid=NjQxOXw1YTRiMGIyYnwxMzQ2NTg2MjYwfDMxOTV8MTY5NQ==&amp;nothumb=yes"><strong>下载附件</strong>(9.9 KB)</a></p><p>我们感兴趣的角度是向量R和X，Y，Z轴之间的夹角，那就令这些角度为Axr，Ayr，Azr。观察由R和Rx组成的直角三角形：<br>cos(Axr) = Rx / R , 类似的：<br>cos(Ayr) = Ry / R<br>cos(Azr) = Rz / R<br>从 公式1我们可以推导出 R = SQRT( Rx^2 + Ry^2 + Rz^2)<br>通过arccos()函数（cos()的反函数）我们可以计算出所需的角度：<br>Axr = arccos(Rx/R)<br>Ayr = arccos(Ry/R)<br>Azr = arccos(Rz/R)<br>我们花了大段的篇幅来解释加速度计模型，最后所要的只是以上这几个公式。根据你的应用场合，你可能会用到我们推导出来的几个过渡公式。我们接下来要介绍陀螺仪模块，并向大家介绍怎么融合加速度计和陀螺仪的数据以得到更精确的倾角值。<br>但在此之前，我们再介绍几个很常用的公式：<br>cosX = cos(Axr) = Rx / R<br>cosY = cos(Ayr) = Ry / R<br>cosZ = cos(Azr) = Rz / R<br>这三个公式通常称作 <a href="http://en.wikipedia.org/wiki/Direction_cosine">方向余弦</a> ，它主要表达了单位向量（长度为1的向量）和R向量具有相同的方向。你可以很容易地验证：<br>SQRT（cosX ^ 2 + COSY ^ 2 + cosZ ^ 2）= 1<br>这是个很好的性质，因为它避免了我们一直检测R向量的模（长度）。通常如果我们只是对惯性力的方向感兴趣，那标准化模长以简化其他计算是个明智的选择。<br>第二部分陀螺仪<br>对于陀螺仪我们将不会像加速度计一样介绍它的等价盒子模型，而是直接跳到加速度计的第二个模型，通过这个模型我们会向大家介绍陀螺仪是怎么工作的。<br><img src="http://image.geek-workshop.com/forum/201208/22/163859eepfepkeh1glt1lw.png"></p><p>2012-8-22 16:38 上传</p><p><a href="http://blog.csdn.net/zhuanghe_xing/article/details/forum.php?mod=attachment&amp;aid=NjQyMHxlMzYwMGE3ZHwxMzQ2NTg2MjYwfDMxOTV8MTY5NQ==&amp;nothumb=yes"><strong>下载附件</strong>(12.55 KB)</a></p><p>陀螺仪的每个通道检测一个轴的旋转。例如，一个2轴陀螺仪检测绕X和Y轴的旋转。为了用数字来表达这些旋转，我们先引进一些符号。首先我们定义：<br>Rxz – 惯性力矢量R在XZ平面上的投影<br>Ryz – 惯性力矢量R在YZ平面的上投影<br>在由Rxz和Rz组成的直角三角形中，运用勾股定理可得：<br>Rxz^2 = Rx^2 + Rz^2 ，同样：<br>Ryz^2 = Ry^2 + Rz^2<br>同时注意：<br>R^2 = Rxz^2 + Ry^2 ，这个公式可以 公式1和上面的公式推导出来，也可由R和Ryz所组成的直角三角形推导出来<br>R ^ 2 = Ryz ^ 2 + RX ^ 2<br>在这篇文章中我们不会用到这些公式，但知道模型中的那些数值间的关系有助于理解。<br>相反，我们按如下方法定义Z轴和Rxz、Ryz向量所成的夹角：<br>AXZ - Rxz（矢量R在XZ平面的投影）和Z轴所成的夹角<br>AYZ - Ryz（矢量R在YZ平面的投影）和Z轴所成夹角<br>现在我们离陀螺仪要测量的东西又近了一步。陀螺仪测量上面定义的角度的变化率。换句话说，它会输出一个与上面这些角度变化率线性相关的值。为了解释这一点，我们先假设在t0时刻，我们已测得绕Y轴旋转的角度（也就是Axz），定义为Axz0，之后在t1时刻我们再次测量这个角度，得到Axz1。角度变化率按下面方法计算：<br>RateAxz = (Axz1 – Axz0) / (t1 – t0).<br>如果用度来表示角度，秒来表示时间，那这个值的单位就是 度/秒。这就是陀螺仪检测的东西。<br>在实际运用中，陀螺仪一般都不会直接给你一个单位为度/秒的值（除非它是个特殊的数字陀螺仪）。就像加速度计一样，你会得到一个ADC值并且要用类似 公式2的式子将其转换成单位为 度/秒的值。让我们来介绍陀螺仪输出值转换中的ADC部分（假设使用10位ADC模块，如果是8位ADC，用1023代替255，如果是12为ADC用4095代替1023）。<br>RateAxz = (AdcGyroXZ * Vref / 1023 – VzeroRate) / Sensitivity <strong>公式3</strong><br>RateAyz = (AdcGyroYZ * Vref / 1023 – VzeroRate) / Sensitivity<br>AdcGyroXZ，AdcGyroYZ - 这两个值由ADC读取，它们分别代表矢量R的投影在XZ和YZ平面内里的转角，也可等价的说，旋转可分解为单独绕Y和X轴的运动。<br>Vref – ADC的参考电压，上例中我们使用3.3V<br>VzeroRate – 是零变化率电压，换句话说它是陀螺仪不受任何转动影响时的输出值，对 <a href="http://gadgetgangster.com/find-a-project/56?projectnum=213">Acc Gyro</a>板来说，可以认为是1.23V（此值通常可以在说明书中找到——但千万别相信这个值，因为大多数的陀螺仪在焊接后会有一定的偏差，所以可以使用电压计测量每个通道的输出值，通常这个值在焊接后就不会改变，如果有跳动，在设备使用前写一个校准程序对其进行测量，用户应当在设备启动的时候保持设备静止以进行校准）。<br>Sensitivity –陀螺仪的灵敏度，单位mV/(deg/s)，通常写作mV/deg/s,它的意思就是如果旋转速度增加1°/s,陀螺仪的输出就会增加多少mV。 <a href="http://gadgetgangster.com/find-a-project/56?projectnum=213">Acc_Gyro</a>板的灵敏度值是2mV/deg/s或0.002V/deg/s<br>让我们举个例子，假设我们的ADC模块返回以下值：<br>AdcGyroXZ = 571<br>AdcGyroXZ = 323<br>用上面的公式，在代入 <a href="http://gadgetgangster.com/find-a-project/56?projectnum=213">Acc Gyro</a>板的参数，可得：<br>RateAxz = (571 * 3.3V / 1023 – 1.23V) / ( 0.002V/deg/s) =~ 306 deg/s<br>RateAyz = (323 * 3.3V / 1023 – 1.23V) / ( 0.002V/deg/s) =~ -94 deg/s<br>换句话说设备绕Y轴（也可以说在XZ平面内）以306°/s速度和绕X轴（或者说YZ平面内）以-94°/s的速度旋转。请注意，负号表示该设备朝着反方向旋转。按照惯例，一个方向的旋转是正值。一份好的陀螺仪说明书会告诉你哪个方向是正的，否则你就要自己测试出哪个旋转方向会使得输出脚电压增加。最好使用示波器进行测试，因为一旦你停止了旋转，电压就会掉回零速率水平。如果你使用的是万用表，你得保持一定的旋转速度几秒钟并同时比较电压值和零速率电压值。如果值大于零速率电压值那说明这个旋转方向是正向。<br>第三部分 将它们综合起来。融合加速度计和陀螺仪的数据。<br>如果你在阅读这篇文章你可能已经有了或准备购买一个IMU设备，或者你准备用独立的加速度计和陀螺仪搭建一个。<br>注：具体的代码实现和算法测试，请阅读这篇文章：<br><a href="http://starlino.com/imu_kalman_arduino.html">http://starlino.com/imu_kalman_arduino.html</a></p><p>在使用整合了加速度计和陀螺仪的IMU设备时，首先要做的就是统一它们的坐标系。最简单的办法就是将加速度计作为参考坐标系。大多数的加速度计技术说明书都会指出对应于物理芯片或设备的XZY轴方向。例如，下面就是Acc Gyro板的说明书中给出的XYZ轴方向：<br><img src="http://image.geek-workshop.com/forum/201208/22/16390056u825bbb2j10x80.png"></p><p>2012-8-22 16:39 上传</p><p><a href="http://blog.csdn.net/zhuanghe_xing/article/details/forum.php?mod=attachment&amp;aid=NjQyMXxmZDNmNmQ3MnwxMzQ2NTg2MjYwfDMxOTV8MTY5NQ==&amp;nothumb=yes"><strong>下载附件</strong>(35.18 KB)</a></p><p>接下来的步骤是：<br>- 确定陀螺仪的输出对应到上述讨论的RateAxz，RateAyz值。<br>- 根据陀螺仪和加速度计的位置决定是否要反转输出值<br>不要设想陀螺仪陀的输出有XY，它会适应加速度计坐标系里的任何轴，尽管这个输出是IMU模块的一部分。最好的办法就是测试。<br>接下来的示例用来确定哪个陀螺仪的输出对应RateAxz。<br>- 首先将设备保持水平。加速度计的XY轴输出会是零加速度电压（ <a href="http://gadgetgangster.com/find-a-project/56?projectnum=213">Acc Gyro</a>板的值是1.65V）<br>- 接下来将设备绕Y轴旋转，换句话说就是将设备在XZ平面内旋转，所以X、Z的加速度输出值会变化而Y轴保持不变。<br>-当以匀速旋转设备的时候，注意陀螺仪的哪个通道输出值变化了，其他输出应该保持不变。<br>- 在陀螺仪绕Y轴旋转（在XZ平面内旋转）的时候输出值变化的就是AdcGyroXZ，用于计算RateAxz<br>-最后一步，确认旋转的方向是否和我们的模型对应，因为陀螺仪和加速度的位置关系，有时候你可能要把RateAxz值反向<br>-重复上面的测试，将设备绕Y轴旋转，这次查看加速度计的X轴输出（也就是AdcRx）。如果AdcRx增大（从水平位置开始旋转的第一个90°），那AdcGyroXZ应当减小。这是因为我们观察的是重力矢量，当设备朝一个方向旋转时矢量会朝相反的方向旋转（相对坐标系运动）。所以，如果你不想反转RateAxz，你可以在 <strong>公式3</strong>中引入正负号来解决这个问题：<br>RateAxz = InvertAxz * (AdcGyroXZ * Vref / 1023 – VzeroRate) / Sensitivity ,其中InvertAxz= 1 或-1<br>同样的方法可以用来测试RateAyz，将设备绕X轴旋转，你就能测出陀螺仪的哪个输出对应于RateAyz，以及它是否需要反转。一旦你确定了InvertAyz，你就能可以用下面的公式来计算RateAyz：<br>RateAyz = InvertAyz * (AdcGyroYZ * Vref / 1023 – VzeroRate) / Sensitivity<br>如果对Acc Gyro板进行这些测试，你会得到下面的这些结果：<br>- RateAxz的输出管脚是GX4，InvertAxz = 1<br>- RateAyz输出管脚是GY4，InvertAyz = 1<br>从现在开始我们认为你已经设置好了IMU模块并能计算出正确的Axr，Ayr，Azr值（在第一部分加速度计中定义）以及RateAyz，RateAyz（在第二部分陀螺仪中）。下一步，我们分析这些值之间的关系并得到更准确的设备和地平面之间的倾角。<br>你可能会问自己一个问题，如果加速度计已经告诉我们Axr，Ayr，Azr的倾角，为什么还要费事去得到陀螺仪的数据？答案很简单：加速度计的数据不是100%准确的。有几个原因，还记加速度计测量的是惯性力，这个力可以由重力引起（理想情况只受重力影响），当也可能由设备的加速度（运动）引起。因此，就算加速度计处于一个相对比较平稳的状态，它对一般的震动和机械噪声很敏感。这就是为什么大部分的IMU系统都需要陀螺仪来使加速度计的输出更平滑。但是怎么办到这点呢？陀螺仪不受噪声影响吗？<br>陀螺仪也会有噪声，但由于它检测的是旋转，因此对线性机械运动没那么敏感，不过陀螺仪有另外一种问题，比如漂移（当选择停止的时候电压不会回到零速率电压）。然而，通过计算加速度计和陀螺仪的平均值我们能得到一个相对更准确的当前设备的倾角值，这比单独使用加速度计更好。<br>接下来的步骤我会介绍一种算法，算法受卡尔曼滤波中的一些思想启发，但是它更简单并且更容易在嵌入式设备中实现。在此之前，让我们先看看我们需要算法计算什么值。所要算的就是重力矢量R=[Rx,Ry,Rz]，它可由其他值推导出来，如Axr，Ayr，Azr或者cosX，cosY，cosZ，由这些值我们能得到设备相对地平面的倾角值，这些关系我们在第一部分已经讨论过。有人可能会说-根据第一部分的 公式2我们不是已经得到Rx，Ry，Rz的值了吗？是的，但是记住，这些值只是由加速度计数据推导出来的，如果你直接将它们用于你的程序你会得到难以忍受的噪声。为了避免进一步的混乱，我们重新定义加速度计的测量值：<br>Racc – 是由加速度计测量到得惯性力矢量，它可分解为下面的分量（在XYZ轴上的投影）：<br>RxAcc = (AdcRx * Vref / 1023 – VzeroG) / Sensitivity<br>RyAcc = (AdcRy * Vref / 1023 – VzeroG) / Sensitivity<br>RzAcc = (AdcRz * Vref / 1023 – VzeroG) / Sensitivity<br>现在我们得到了一组只来自于加速度计ADC的值。我们把这组数据叫做“vector”，并使用下面的符号：<br>Racc = [RxAcc,RyAcc,RzAcc]<br>因为这些Racc的分量可由加速度计数据得到，我们可以把它当做算法的输入。<br>请注意Racc测量的是重力，如果你得到的矢量长度约等于1g那么你就是正确的：<br>|Racc| = SQRT(RxAcc^2 +RyAcc^2 + RzAcc^2),<br>但是请确定把矢量转换成下面的矢量非常重要：<br>Racc(normalized) = [RxAcc/|Racc| , RyAcc/|Racc| , RzAcc/|Racc|].<br>这可以确保标准化Racc始终是1。<br>接来下我们引进一个新的向量：<br>Rest = [RxEst,RyEst,RzEst]<br>这就是算法的输出值，它经过陀螺仪数据的修正和基于上一次估算的值。<br>这是算法所做的事：<br>-加速度计告诉我们：“你现在的位置是Racc”<br>我们回答：“谢谢，但让我确认一下”<br>-然后根据陀螺仪的数据和上一次的Rest值修正这个值并输出新的估算值Rest。<br>-我们认为Rest是当前设备姿态的“最佳值”。<br>让我们看看它是怎么实现的。<br>数列的开始，我们先认为加速度值正确并赋值：<br>Rest(0) = Racc(0)<br>Rest和Racc是向量，所以上面的式子可以用3个简单的式子代替，注意别重复了：<br>RxEst（0）= RxAcc（0）<br>RyEst（0）= RyAcc（0）<br>RzEst（0）= RzAcc（0）<br>接下来我们在每个等时间间隔T秒做一次测量，得到新的测量值，并定义为Racc（1），Racc（2），Racc（3）等等。同时，在每个时间间隔我们也计算出新的估算值Rest（1）,Rest（2），Rest（3），等等。<br>假设我们在第n步。我们有两列已知的值可以用：<br>Rest(n-1) – 前一个估算值，Rest(0) = Racc(0)<br>Racc(n) – 当前加速度计测量值<br>在计算Rest（n）前，我们先引进一个新的值，它可由陀螺仪和前一个估算值得到。<br>叫做Rgyro，同样它是个矢量并由3个分量组成：<br>Rgyro = [RxGyro,RyGyro,RzGyro]<br>我们分别计算这个矢量的分量，从RxGyro开始。<br><img src="http://image.geek-workshop.com/forum/201208/22/163901qa8wfgaj8z8ca8kk.png"></p><p>2012-8-22 16:39 上传</p><p><a href="http://blog.csdn.net/zhuanghe_xing/article/details/forum.php?mod=attachment&amp;aid=NjQyMnwxZDk2MjFlNXwxMzQ2NTg2MjYwfDMxOTV8MTY5NQ==&amp;nothumb=yes"><strong>下载附件</strong>(12.55 KB)</a></p><p>首先观察陀螺仪模型中下面的关系，根据由Rz和Rxz组成的直角三角形我们能推出：<br>tan(Axz) = Rx/Rz =&gt; Axz = atan2(Rx,Rz)<br>你可能从未用过atan2这个函数，它和atan类似，但atan返回值范围是（-PI/2,PI/2），atan2返回值范围是（-PI，PI），并且他有两个参数。它能将Rx，Rz值转换成360°（-PI，PI）内的角度。更多信息请阅读 <a href="http://en.wikipedia.org/wiki/Atan2">atan2</a>.<br>所以，知道了RxEst（n-1）和RzEst（n-1）我们发现：<br>Axz(n-1) = atan2( RxEst(n-1) , RzEst(n-1) ).<br>记住，陀螺仪测量的是Axz角度变化率，因此，我们可以按如下方法估算新的角度Axz（n）：<br>Axz(n) = Axz(n-1) + RateAxz(n) * T<br>请记住，RateAxz可由陀螺仪ADC读取得到。通过使用平均转速可由得到一个更准确的公式：<br>RateAxzAvg =（RateAxz（N）+ RateAxz（N-1））/ 2<br>Axz(n) = Axz(n-1) + RateAxzAvg * T<br>同理可得：<br>Ayz(n) = Ayz(n-1) + RateAyz(n) * T<br>好了，现在我们有了Axz（n），Ayz（n）。现在我们如何推导出RxGyro/RyGyro?根据 公式1我们可以把Rgyro长度写成下式：<br>| Rgyro | = SQRT（RxGyro ^ 2 + RyGyro ^ 2 + RzGyro ^ 2）<br>同时，因为我们已经将Racc标准化，我们可以认为它的长度是1并且旋转后保持不变，所以写成下面的方式相对比较安全：<br>| Rgyro | = 1<br>我们暂时采用更短的符号进行下面的计算：<br>x =RxGyro , y=RyGyro, z=RzGyro<br>根据上面的关系可得：<br>x = x / 1 = x / SQRT(x^2+y^2+z^2)<br>分子分母同除以SQRT（X ^ 2 + Z ^ 2）<br>x = ( x / SQRT(x^2 + z^2) ) / SQRT( (x^2 + y^2 + z^2) / (x^2 + z^2) )<br>注意x / SQRT(x^2 + z^2) = sin(Axz), 所以:<br>x = sin(Axz) / SQRT (1 + y^2 / (x^2 + z^2) )<br>将SQRT内部分式的分子分母同乘以z^2<br>x = sin(Axz) / SQRT (1 + y^2 * z ^2 / (z^2 * (x^2 + z^2)) )<br><strong>注意 z / SQRT(x^2 + z^2) = cos(Axz)， y / z = tan(Ayz), 所以最后可得:</strong><br>x = sin(Axz) / SQRT (1 + cos(Axz)^2 * tan(Ayz)^2 )<br>替换成原来的符号可得：<br>RxGyro = sin(Axz(n)) / SQRT (1 + cos(Axz(n))^2 * tan(Ayz(n))^2 )<br>同理可得：<br>RyGyro = sin(Ayz(n)) / SQRT (1 + cos(Ayz(n))^2 * tan(Axz(n))^2 )<br>提示：这个公式还可以更进一步简化。分式两边同除以sin（axz（你））可得：<br>RxGyro = 1 / SQRT (1/ sin(Axz(n))^2 + cos(Axz(n))^2 / sin(Axz(n))^2 * tan(Ayz(n))^2 )<br>RxGyro = 1 / SQRT (1/ sin(Axz(n))^2 + cot(Axz(n))^2 * sin(Ayz(n))^2 / cos(Ayz(n))^2 )<br>现在加减  cos(Axz(n))^2/sin(Axz(n))^2  = cot(Axz(n))^2<br>RxGyro = 1 / SQRT (1/ sin(Axz(n))^2 - cos(Axz(n))^2/sin(Axz(n))^2  + cot(Axz(n))^2 * sin(Ayz(n))^2 / cos(Ayz(n))^2 + cot(Axz(n))^2 )<br>综合条件1、2和3、4可得：<br>RxGyro = 1 / SQRT (1 +  cot(Axz(n))^2 * sec(Ayz(n))^2 ),   其中 cot(x) = 1 / tan(x) ， sec(x) = 1 / cos(x)<br>这个公式只用了2个三角函数并且计算量更低。如果你有Mathematica程序，通过使用 FullSimplify [Sin[A]^2/ ( 1 + Cos[A]^2 * Tan[B]^2)]你可以验证这个公式。</p><p>现在我们发现：<br>RzGyro = Sign(RzGyro)*SQRT(1 – RxGyro^2 – RyGyro^2).<br>其中，当 RzGyro&gt;=0时，Sign(RzGyro) = 1 , 当 RzGyro&lt;0时，Sign(RzGyro) = -1 。<br>一个简单的估算方法：<br>Sign(RzGyro) = Sign(RzEst(n-1))<br>在实际应用中，当心RzEst（n-1）趋近于0。这时候你可以跳过整个陀螺仪阶段并赋值：Rgyro=Rest（n-1）。Rz可以用作计算Axz和Ayz倾角的参考，当它趋近于0时，它可能会溢出并引发不好的后果。这时你会得到很大的浮点数据，并且tan()/atan()函数得到的结果会缺乏精度。</p><p>现在我们回顾一下已经得到的结果，我们在算法中的第n步，并计算出了下面的值：<br>Racc – 加速度计读取的当前值<br>Rgyro –根据Rest(-1)和当前陀螺仪读取值所得<br>我们根据哪个值来更新Rest（n）呢？你可能已经猜到，两者都采用。我们会用一个加权平均值，得：<br>Rest(n) = (Racc * w1 + Rgyro * w2 ) / (w1 + w2)<br>分子分母同除以w1，公式可简化成：<br>Rest(n) = (Racc * w1/w1 + Rgyro * w2/w1 ) / (w1/w1 + w2/w1)<br>令w2=w1=wGyro，可得：<br>Rest(n) = (Racc + Rgyro * wGyro ) / (1 + wGyro)<br>在上面的公式中，wGyro表示我们对加速度计和陀螺仪的相信程度。这个值可以通过测试确定，根据经验值5-20之间会得到一个很好的结果。<br>此算法和卡尔曼滤波最主要的差别是它的权重是相对固定的，而卡尔曼滤波中的权重会随着加速度计读取的噪声而改变。卡尔曼滤波注重给你一个“最好”的理论结果，而此算法给你的是实际项目中“够用”的结果。你可以实现一个算法，它能根据测量的噪声而改变wGyro值，但对大部分应用来说固定的权重也能工作的很好。<br>现在得到最新的估算值还差一步：<br>RxEst(n) = (RxAcc + RxGyro * wGyro ) / (1 + wGyro)<br>RyEst(n) = (RyAcc + RyGyro * wGyro ) / (1 + wGyro)<br>RzEst(n) = (RzAcc + RzGyro * wGyro ) / (1 + wGyro)<br>现在，再次标准化矢量：<br>R = SQRT(RxEst(n) ^2 + RyEst(n)^2 + RzEst(n)^2 )<br>RxEst(n) = RxEst(n)/R<br>RyEst(n) = RyEst(n)/R<br>RzEst(n) = RzEst(n)/R<br>现在，可以再次进行下一轮循环了。<br><strong>注：</strong>关于此算法的具体实现和测试，请阅读这篇文章：<br><a href="http://starlino.com/imu_kalman_arduino.html">http://starlino.com/imu_kalman_arduino.html</a></p><p>加速度计和陀螺仪IMU融合的其他资源：<br><a href="http://www.mikroquad.com/pub/Research/ComplementaryFilter/filter.pdf">http://www.mikroquad.com/pub/Res … ryFilter/filter.pdf</a></p><p><a href="http://stackoverflow.com/questions/1586658/combine-gyroscope-and-accelerometer-data">http://stackoverflow.com/questio … -accelerometer-data</a><br><a href="http://www.dimensionengineering.com/accelerometers.htm">http://www.dimensionengineering.com/accelerometers.htm</a></p>]]></content>
      
      
      <categories>
          
          <category> 电子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陀螺仪--九轴</title>
      <link href="/posts/962b2335/"/>
      <url>/posts/962b2335/</url>
      
        <content type="html"><![CDATA[<center>   </center><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>传感器的调试过程，一般根据原厂提供demo代码，调试数据接口，将数据流打通即可，在VR中，当带上头显设备，运行应用时，出现漂移、延迟、不回归问题，往往束手无策，解决这些小问题，往往占用很多的时间，希望通过自己整理的知识，明确调试的方向，提高调试效率，达到好的调试效果。自己近几年在Android平台上导入过多种9轴传感器，做过一些sensor内部分享，而且近半年来从事VR开发工作，VR对9轴传感器要求比手机、平板严格更多，遇到的问题也更多，在开发过程中不断学习和思考，与传感器原厂RD沟通和学习。</p><h1 id="9轴传感器"><a href="#9轴传感器" class="headerlink" title="9轴传感器"></a>9轴传感器</h1><p>9轴传感器包括3轴加速度计、3轴陀螺仪、3轴磁力计，在实际应用中，需要把这些数据需要经过融合算法后，才能够被应用程序使用，下面对每种传感器功能、原理以及融合算法进行介绍。</p><h2 id="加速度计"><a href="#加速度计" class="headerlink" title="加速度计"></a>加速度计</h2><p>人们常说的G-sensor，用来检测物理在X、Y、Z轴上的重力加速度，单位:m/s^2.<br>以手机为例，X、Y、Z轴如下图所示（右手坐标系）：<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101251281"><br>当手机平放在桌面时，Z轴指向天空，这时候X、Y轴的数值接近为0，Z轴的重力加速度约为9.81m/s^2，将手机翻转后，即屏幕面朝向桌面，此时的Z轴重力加速度约为-9.81m/s^2。<br>X、Y轴指向天空时，与上面Z轴同理，有兴趣的可以在手机上安装一个”sensor_list.apk”来抓取这些数据。</p><ul><li>原理<br><a href="http://www.starlino.com/imu_guide.html">这里是英文介绍</a>，中文版本如下：<br>当我们在想象一个加速度计的时候我们可以把它想作一个圆球在一个方盒子中。你可能会把它想作一个饼干或者甜圈，但我就把它当做一个球好了：<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101306719"><br>我们假定这个盒子不在重力场中或者其他任何会影响球的位置的场中，球处于盒子的正中央。你可以想象盒子在外太空中，远离任何天体，如果很难想象，那就当做盒子在航天飞机中，一切东西都处于无重力状态。在上面的图中你可以看到我们给每个轴分配了一对墙（我们移除了Y+以此来观察里面的情况）。设想每面墙都能感测压力。如果我们突然把盒子向左移动（加速度为1g=9.8m/s^2），那么球会撞上X-墙。然后我们检测球撞击墙面产生的压力，根据F=ma，计算出X轴加速度输出值为-1g。<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101317203"><br>请注意加速度计检测到的力方向与它本身加速度的方向是相反的。这种力量通常被称为惯性力或假想力 。在这个模型中你应该明白加速度计是通过间接测量力对一个墙面的作用来测量加速度的，在实际应用中，可能通过弹簧等装置来测量力。这个力可以是加速度引起的，但在下面的例子中，我们会发现它不一定是加速度引起的。<br>如果我们把模型放在地球上，球会落在Z-墙面上并对其施加一个1g的力，见下图：<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101342743"><br>在这种情况下盒子没有移动但我们任然读取到Z轴有-1g的值。球在墙壁上施加的压力是由引力造成的。在理论上，它可以是不同类型的力量，例如，你可以想象我们的球是铁质的，将一个磁铁放在盒子旁边那球就会撞上另一面墙。引用这个例子只是为了说明加速度计的本质是检测力而非加速度。只是加速度所引起的惯性力正好能被加速度计的检测装置所捕获。<br>虽然这个模型并非一个MEMS传感器的真实构造，但它用来解决与加速度计相关的问题相当有效。实际上有些类似传感器中有金属小球，它们称作倾角开关，但是它们的功能更弱，只能检测设备是否在一定程度内倾斜，却不能得到倾斜的程度。<br>到目前为止，我们已经分析了单轴的加速度计输出，这是使用单轴加速度计所能得到的。三轴加速度计的真正价值在于它们能够检测全部三个轴的惯性力。让我们回到盒子模型，并将盒子向右旋转45度。现在球会与两个面接触：Z-和X-，见下图：<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101354118"><br>0.71g这个值是不是任意的，它们实际上是1/2的平方根的近似值。我们介绍加速度计的下一个模型时这一点会更清楚。<br>在上一个模型中我们引入了重力并旋转了盒子。在最后的两个例子中我们分析了盒子在两种情况下的输出值，力矢量保持不变。虽然这有助于理解加速度计是怎么和外部力相互作用的，但如果我们将坐标系换为加速度的三个轴并想象矢量力在周围旋转，这会更方便计算。<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101540369"><br>请看看在上面的模型，我保留了轴的颜色，以便你的思维能更好的从上一个模型转到新的模型中。想象新模型中每个轴都分别垂直于原模型中各自的墙面。矢量R是加速度计所检测的矢量（它可能是重力或上面例子中惯性力的合成）。RX，RY，RZ是矢量R在X，Y，Z上的投影。请注意下列关系：<br>R ^ 2 = RX ^ 2 + RY ^ 2 + RZ ^ 2（公式1）<br>此公式等价于三维空间勾股定理。<br>还记得我刚才说的1/2的平方根0.71不是个随机值吧。如果你把它们代回上式，回顾一下重力加速度是1g，那我们就能验证：<br>1 ^ 2 =（SQRT（1/2））^ 2 + 0 ^ 2 +（SQRT（1/2））^ 2<br>在公式1中简单的取代： R=1, Rx = -SQRT(1/2), Ry = 0 , Rz = -SQRT(1/2)<br>经过一大段的理论序言后，我们和实际的加速度计很靠近了。RX，RY，RZ值是实际中加速度计输出的线性相关值，你可以用它们进行各种计算。<br>在我们运用它之前我们先讨论一点获取加速度计数据的方法。大多数加速度计可归为两类：数字和模拟。数字加速度计可通过I2C，SPI或USART方式获取信息，而模拟加速度计的输出是一个在预定范围内的电压值，你需要用ADC（模拟量转数字量）模块将其转换为数字值。我将不会详细介绍ADC是怎么工作的，部分原因是这是个很广的话题，另一个原因是不同平台的ADC都会有差别。有些MCU具有内置ADC模块，而有些则需要外部电路进行ADC转换。不管使用什么类型的ADC模块，你都会得到一个在一定范围内的数值。例如一个10位ADC模块的输出值范围在0 .. 1023间，请注意，1023 = 2 ^ 10 -1。一个12位ADC模块的输出值范围在0 .. 4095内，注意，4095 = 2 ^ 12-1。<br>我们继续，先考虑下一个简单的例子，假设我们从10位ADC模块得到了以下的三个轴的数据：<br>AdcRx = 586<br>AdcRy = 630<br>AdcRz = 561<br>每个ADC模块都有一个参考电压，假设在我们的例子中，它是3.3V。要将一个10位的ADC值转成电压值，我们使用下列公式：<br>VoltsRx = AdcRx * VREF / 1023<br>小注：8位ADC的最大值是255 = 2 ^ 8 -1，12位ADC最大值是4095 = 2 ^ 12 -1。<br>将3个轴的值代入上式，得到：<br>VoltsRx = 586 * 3.3 / 1023 =～1.89V（结果取两位小数）<br>VoltsRy = 630 * 3.3 / 1023 =～2.03V<br>VoltsRz = 561 * 3.3 / 1023 =～1.81V<br>每个加速度计都有一个零加速度的电压值，你可以在它的说明书中找到，这个电压值对应于加速度为0g。通过计算相对0g电压的偏移量我们可以得到一个有符号的电压值。比方说，0g电压值 VzeroG= 1.65V，通过下面的方式可以得到相对0g电压的偏移量:<br>DeltaVoltsRx = 1.89V - 1.65V = 0.24V<br>DeltaVoltsRy = 2.03V - 1.65V = 0.38V<br>DeltaVoltsRz = 1.81V - 1.65V = 0.16V<br>现在我们得到了加速度计的电压值，但它的单位还不是g（9.8m/s^2），最后的转换，我们还需要引入加速度计的灵敏度（Sensitivity），单位通常是 mV/g。比方说，加速度计的灵敏度 Sensitivity= 478.5mV / g = 0.4785V /g。灵敏度值可以在加速度计说明书中找到。要获得最后的单位为g的加速度，我们使用下列公式计算：<br>RX = DeltaVoltsRx /Sensitivity<br>RX = 0.24V / 0.4785V / G =～0.5g<br>RY = 0.38V / 0.4785V / G =～0.79g<br>RZ = 0.16V / 0.4785V / G =～0.33g<br>当然，我们可以把所有的步骤全部放在一个式子里，但我想通过介绍每一个步骤以便让你了解怎么读取一个ADC值并将其转换为单位为g的矢量力的分量。<br>Rx = (AdcRx * Vref / 1023 – VzeroG) / Sensitivity (公式2)<br>Ry = (AdcRy * Vref / 1023 – VzeroG) / Sensitivity<br>Rz = (AdcRz * Vref / 1023 – VzeroG) / Sensitivity<br>现在我们得到了惯性力矢量的三个分量，如果设备除了重力外不受任何外力影响，那我们就可以认为这个方向就是重力矢量的方向。如果你想计算设备相对于地面的倾角，可以计算这个矢量和Z轴之间的夹角。如果你对每个轴的倾角都感兴趣，你可以把这个结果分为两个分量：X轴、Y轴倾角，这可以通过计算重力矢量和X、Y轴的夹角得到。计算这些角度比你想象的简单，现在我们已经算出了Rx，Ry，Rz的值，让我们回到我们的上一个加速度模型，再加一些标注上去：<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101555463"><br>我们感兴趣的角度是向量R和X，Y，Z轴之间的夹角，那就令这些角度为Axr，Ayr，Azr。观察由R和Rx组成的直角三角形：<br>cos(Axr) = Rx / R , 类似的：<br>cos(Ayr) = Ry / R<br>cos(Azr) = Rz / R<br>从公式1我们可以推导出 R = SQRT( Rx^2 + Ry^2 + Rz^2)<br>通过arccos()函数（cos()的反函数）我们可以计算出所需的角度：<br>Axr = arccos(Rx/R)<br>Ayr = arccos(Ry/R)<br>Azr = arccos(Rz/R)<br>我们花了大段的篇幅来解释加速度计模型，最后所要的只是以上这几个公式。根据你的应用场合，你可能会用到我们推导出来的几个过渡公式。我们接下来要介绍陀螺仪模块，并向大家介绍怎么融合加速度计和陀螺仪的数据以得到更精确的倾角值。<br>但在此之前，我们再介绍几个很常用的公式：<br>cosX = cos(Axr) = Rx / R<br>cosY = cos(Ayr) = Ry / R<br>cosZ = cos(Azr) = Rz / R<br>这三个公式通常称作方向余弦 ，它主要表达了单位向量（长度为1的向量）和R向量具有相同的方向。你可以很容易地验证：<br>SQRT（cosX ^ 2 + COSY ^ 2 + cosZ ^ 2）= 1<br>这是个很好的性质，因为它避免了我们一直检测R向量的模（长度)。通常如果我们只是对惯性力的方向感兴趣，那标准化模长以简化其他计算是个明智的选择。</li><li>常用加速度传感器<br>加速度计种类繁多，MMA、LSM、MPU、BMA等系列，如：MMA7460、MMA8452、MPU6050（A+G）、MPU6800(A+G)、LSM6DSL(A+G)、IMC20603(A+G)、MPU9150（A+G+M）</li><li>使用场景<br>加速度计通过一定的算法，就可以做成我们常用的功能，如：计步器、拍照防抖、GPS补偿、跌落保护、图像旋转、游戏控制器等。</li></ul><h2 id="陀螺仪"><a href="#陀螺仪" class="headerlink" title="陀螺仪"></a>陀螺仪</h2><p>通常称为Gyro-sensor，用来测量在X、Y、Z轴上的旋转速率，单位:rad/s。<br>以手机为例，将手机平放桌面，屏幕朝上，以逆时针方向旋转手机，获得到的是Z轴的加速度值。<br>有兴趣可以安装“sensor_list.apk”工具，来查看X、Y、Z轴的加速度值。</p><ul><li>原理<br>对于陀螺仪我们将不会像加速度计一样介绍它的等价盒子模型，而是直接跳到加速度计的第二个模型，通过这个模型我们会向大家介绍陀螺仪是怎么工作的。<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101615317"><br>陀螺仪的每个通道检测一个轴的旋转。例如，一个2轴陀螺仪检测绕X和Y轴的旋转。为了用数字来表达这些旋转，我们先引进一些符号。首先我们定义：<br>Rxz – 惯性力矢量R在XZ平面上的投影<br>Ryz – 惯性力矢量R在YZ平面的上投影<br>在由Rxz和Rz组成的直角三角形中，运用勾股定理可得：<br>Rxz^2 = Rx^2 + Rz^2 ，同样：<br>Ryz^2 = Ry^2 + Rz^2<br>同时注意：<br>R^2 = Rxz^2 + Ry^2 ，这个公式可以公式1和上面的公式推导出来，也可由R和Ryz所组成的直角三角形推导出来<br>R ^ 2 = Ryz ^ 2 + RX ^ 2<br>在这篇文章中我们不会用到这些公式，但知道模型中的那些数值间的关系有助于理解。<br>相反，我们按如下方法定义Z轴和Rxz、Ryz向量所成的夹角：<br>AXZ - Rxz（矢量R在XZ平面的投影）和Z轴所成的夹角<br>AYZ - Ryz（矢量R在YZ平面的投影）和Z轴所成夹角<br>现在我们离陀螺仪要测量的东西又近了一步。陀螺仪测量上面定义的角度的变化率。换句话说，它会输出一个与上面这些角度变化率线性相关的值。为了解释这一点，我们先假设在t0时刻，我们已测得绕Y轴旋转的角度（也就是Axz），定义为Axz0，之后在t1时刻我们再次测量这个角度，得到Axz1。角度变化率按下面方法计算：<br>RateAxz = (Axz1 – Axz0) / (t1 – t0).<br>如果用度来表示角度，秒来表示时间，那这个值的单位就是 度/秒。这就是陀螺仪检测的东西。<br>在实际运用中，陀螺仪一般都不会直接给你一个单位为度/秒的值（除非它是个特殊的数字陀螺仪）。就像加速度计一样，你会得到一个ADC值并且要用类似公式2的式子将其转换成单位为 度/秒的值。让我们来介绍陀螺仪输出值转换中的ADC部分（假设使用10位ADC模块，如果是8位ADC，用1023代替255，如果是12为ADC用4095代替1023）。<br>RateAxz = (AdcGyroXZ * Vref / 1023 – VzeroRate) / Sensitivity 公式3<br>RateAyz = (AdcGyroYZ * Vref / 1023 – VzeroRate) / Sensitivity<br>AdcGyroXZ，AdcGyroYZ - 这两个值由ADC读取，它们分别代表矢量R的投影在XZ和YZ平面内里的转角，也可等价的说，旋转可分解为单独绕Y和X轴的运动。<br>Vref – ADC的参考电压，上例中我们使用3.3V<br>VzeroRate – 是零变化率电压，换句话说它是陀螺仪不受任何转动影响时的输出值，对调试板来说，可以认为是1.23V（此值通常可以在说明书中找到——但千万别相信这个值，因为大多数的陀螺仪在焊接后会有一定的偏差，所以可以使用电压计测量每个通道的输出值，通常这个值在焊接后就不会改变，如果有跳动，在设备使用前写一个校准程序对其进行测量，用户应当在设备启动的时候保持设备静止以进行校准）。<br>Sensitivity –陀螺仪的灵敏度，单位mV/(deg/s)，通常写作mV/deg/s,它的意思就是如果旋转速度增加1°/s,陀螺仪的输出就会增加多少mV。调试板的灵敏度值是2mV/deg/s或0.002V/deg/s<br>让我们举个例子，假设我们的ADC模块返回以下值：<br>AdcGyroXZ = 571<br>AdcGyroXZ = 323<br>用上面的公式，在代入调试板的参数，可得：<br>RateAxz = (571 * 3.3V / 1023 – 1.23V) / ( 0.002V/deg/s) =~ 306 deg/s<br>RateAyz = (323 * 3.3V / 1023 – 1.23V) / ( 0.002V/deg/s) =~ -94 deg/s<br>换句话说设备绕Y轴（也可以说在XZ平面内）以306°/s速度和绕X轴（或者说YZ平面内）以-94°/s的速度旋转。请注意，负号表示该设备朝着反方向旋转。按照惯例，一个方向的旋转是正值。一份好的陀螺仪说明书会告诉你哪个方向是正的，否则你就要自己测试出哪个旋转方向会使得输出脚电压增加。最好使用示波器进行测试，因为一旦你停止了旋转，电压就会掉回零速率水平。如果你使用的是万用表，你得保持一定的旋转速度几秒钟并同时比较电压值和零速率电压值。如果值大于零速率电压值那说明这个旋转方向是正向。</li><li>常用陀螺仪传感器<br>目前市面上较多的都是二合一模块（加速度+陀螺仪），如：MPU6050（A+G）、MPU6800(A+G)、LSM6DSL(A+G)、IMC20603(A+G)、MPU9150（A+G+M）。</li><li>使用场景<br>航海、航空、游戏、拍照防抖、控制等。</li></ul><h2 id="磁力计"><a href="#磁力计" class="headerlink" title="磁力计"></a>磁力计</h2><ul><li>原理<br><a href="http://www.stmcu.org/article/id-261634">ST对电子罗盘的详细介绍</a>。</li><li>常用磁力计传感器<br>AKM8963（很经典的一颗，目前停产）、AKM09911、AKM09915、LIS3MDL，磁传感器目前还是AKM一家独大，其他家的性能差距还是比较明显的。</li><li>使用场景<br>主要是指南针，在应用中对6轴数据进行偏航校正。</li></ul><h2 id="融合算法"><a href="#融合算法" class="headerlink" title="融合算法"></a>融合算法</h2><p>想想我们为什么需要9轴的数据来确认物体的姿态呢？有了加速度计数据可以确定物体摆放的状态，例如有加速度计的手机，可以根据手机的横竖屏状态来触发屏幕相应的旋转，但对于物体的翻转、旋转的快慢无从得知，检测不到物体的瞬时状态，这时候就需要加入陀螺仪，通过加速度和陀螺仪的积分运算（这部分计算可以看下面Oculus的融合算法说明），可以获得到物体的运动状态，积分运算与真实状态存在微小差值，短时间内影响很小，但这个误差会一直累积，随着使用时间增加，就会有明显的偏离，6轴的设备，在转动360度后，图像并不能回到原点，就是这个原因，就像人迷路后找不着北一样，这时候就需要一个准确的方向，因此引入磁力计，来找到正确的方向进行校正。融合算法是通过这9轴的数据来计算出物体正确的姿态。目前9轴融合算法包括卡尔曼滤波、粒子滤波、互补滤波算法，对于开发者而言，所有的融合算法本基本都是丢入9轴传感器的数据和时间戳，然后获取到融合算法输出的四元素，应用所需的就是这组四元素，目前我这里接触到的算法包括：</p><ul><li>Oculus融合算法<br>目前卡尔曼滤波和例子滤波都存在一定的局限性，比较好的选择是互补滤波算法，之前翻译过oculus传感器算法<a href="http://blog.csdn.net/dabenxiong666/article/details/52957370">Oculus:”sensor fusion:Keeping It Simple”</a><br>它的代码实现在openHMD中ofusion_update接口中，有兴趣可以下载openHMD来研究一下。<br><strong>注</strong>：openHMD中的oculus融合算法（已更新于2016.12.01），我们曾经把它应用到项目当中，后来发现这部分算法不包含航向偏移校正。</li><li>互补滤波算法<br>MIT上发表的互补滤波算法的原理和基于Android平台的算法实现，很完整的算法，oculus的算法也是基于互补滤波的，个人认为目前入门融合算法最好的选择<a href="https://www.codeproject.com/articles/729759/android-sensor-fusion-tutorial">MIT互补滤波算法</a>。</li><li>AHRS<br>在四轴飞行器论坛上，比较多人使用AHRS开源融合算法,<a href="https://github.com/TobiasSimon/MadgwickTests/blob/master/MadgwickAHRS.c">这里获取源码</a><br>如果是爱好者，使用开源的算法能满足大多数的需求，另外可以看一下AMO论坛上的这个讨论<a href="http://www.amobbs.com/thread-5492189-1-1.html">捷联惯导算法心得</a>。<br>产品化还是依赖原厂提供的算法。</li></ul><h2 id="传感器调试"><a href="#传感器调试" class="headerlink" title="传感器调试"></a>传感器调试</h2><p>这里不对特定平台（MCU、Android、Linux等），传感器通讯接口（I2C、SPI等）、数据传递子系统(input、IIO等)详细说明，这部分代码由各sensor厂家直接提供，这里主要说明一下调试基本流程和方法：</p><ul><li>通讯接口<br>传感器IC的通讯接口I2C或SPI，通讯接口能够读写正常即可。</li><li>寄存器配置<br>寄存器参数配置，一般原厂会提供，根据自己需求设置full scale(量程)、ODR（采样速率）、中断、休眠模式 即可。</li><li>坐标系转换<br>这3种传感器在实际应用中，都需要调整IC的坐标系与实际坐标系相匹配。IC的坐标系是固定的，参考规格书，这里以20602为例：<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101725183"><br>而实际应用当中，也有自己的坐标系，手机应用（右手坐标系）：<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101733085"><br>unity应用（左手坐标系）：<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101748589"><br>坐标系的匹配，一般通过驱动的旋转矩阵，来调整。这里需要注意，融合算法一般直接适配的是右手坐标系，而VR应用多数是基于unity引擎开发的，即采用左手坐标系，这里不能将IC的坐标系直接与左手坐标系做匹配，否则会有漂移！这个转换应用会有对应的API去做转换，将驱动坐标系与世界坐标系匹配。</li><li>硬件环境<br>另外传感器对于硬件有所要求，比如IC摆放不能靠近边缘，下方走线规范，附近几毫米内不允许有大电流，马达，软磁、硬磁干扰等等，这方面最好是把PCB给原厂审核，磁方面用他们专门的设备扫描磁力计周围的磁场环境是否正常。<br>基本理论搞清楚调试起来就会得心应手，这里提供一个<a href="http://download.csdn.net/detail/dabenxiong666/9718883?locationNum=4&amp;fps=1">Android平台调试sensor的文档</a>，其他平台类似。</li></ul><h2 id="9轴方案选择"><a href="#9轴方案选择" class="headerlink" title="9轴方案选择"></a>9轴方案选择</h2><p>上面主要对传感器的知识做了一些整理和归纳，下面是我们在做9轴方案选择的一些实验,目前选择市面上使用较多的两家（ST和Invensense）9轴方案进行评估、测试，均是用官方建议最优方案，即：<br>ST:LSM6DSL+LIS3MDL<br>Invensense: imc20603+akm09915<br>对比内容包括静态、动态对比以及结合应用体验来评估2种传感器方案，<a href="https://drive.google.com/open?id=0Bx5hCqFqKCggZHRRdV80ZXk0MWc">测试数据包和测试视频</a>。</p><ul><li><p>静态数据</p><p>放置30秒后，开始采集5分钟静态数据,3000~5000组数据（包括欧拉角、四元素、磁数据），数据见附件中的“静态数据”表格</p><ul><li>静态漂移：<br>根据四元素均方差数据计算，5分钟内ST与Invensense静态角度偏差均小于1度，此项2种方案相同。</li><li>Yaw角偏移：<br>Yaw均方差数值接近(ST为0.19，invensense为0.20)，YAW角偏移大概在1度左右，此项2种方案相同。</li></ul></li><li><p>动态数据</p><ul><li>回归测试：<br>放置到固定位置，任意角度运动1分钟，运动过程未超量程（即：运动中，加速度不超过4g，陀螺仪不超过2000dps），放回原位置，然后对比运动前后，看应用的画面是否与运动前一致。如”回归测试视频”所示，Invensense的画面能够基本回到原来的位置，ST的有明显偏移,这个视频对于2种sensor的优劣还是比较明显的。<br>此项Invensense优于ST。</li><li>磁数据测试<br>固定桌面，缓慢旋转2周，抓取3500个数据点，通过matlab作图。<br>Invensense磁数据图：<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101802996"><br>ST磁数据图：<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101810965"><br>说明:测试时，平放板子到桌面，然后缓慢旋转2周（绕Z轴旋转），上图x/y轴分别未经算法处理的X、Y的磁数据，因为ST和Invensense抓取到的磁数据放大倍数不同所以看起来数据量级不一样，但不影响判断，数据的放大倍数只影响圆的半径大小。磁数据是用来对航向（yaw)校正的，关系到9轴数据的准确性。从图上可以看出invensense的磁数据基本落在一个圆内，ST的磁数据在圆内、圆外都有很多离散的点，影响9周数据的准确性。<br>此项Invensense优于ST。</li></ul></li><li><p>应用体验</p><ul><li>收敛速度<br>结合应用测试，Invensense在运动后1秒内收敛完成，而ST的需要2-3秒的校正时间后，才能收敛完。<br>此项Invensense优于ST.</li></ul></li></ul><p>结论：静态数据2种方案相差不大，5分钟内偏移角度都在1度以内，且有磁力计可以纠正航向问题，都能满足需要，但在动态数据上，Invense明显优于ST，在实际体验中Invense收敛快，能回归，所以9轴方案Invensense优于ST。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://developer3.oculus.com/blog/sensor-fusion-keeping-it-simple/">oculars sensor doc</a><br><a href="http://www.starlino.com/imu_guide.html">starlino Imu introduce</a><br><a href="https://developer.android.com/guide/topics/sensors/sensors_overview.html">goole sensor introduce</a><br><a href="http://www.geek-workshop.com/thread-1695-1-1.html">geek-workshop</a><br><a href="http://www.amobbs.com/thread-5492189-1-1.html">捷联惯导算法心得</a></p>]]></content>
      
      
      <categories>
          
          <category> 电子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陀螺仪--mpu6050</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="Ⅰ-陀螺仪"><a href="#Ⅰ-陀螺仪" class="headerlink" title="Ⅰ.陀螺仪"></a>Ⅰ.陀螺仪</h1><p>陀螺仪是用高速回转体的动量矩敏感壳体相对惯性空间绕正交于自转轴的一个或二个轴的角运动检测装置。利用其他原理制成的角运动检测装置起同样功能的也称陀螺仪。<br>从力学的观点近似的分析陀螺的运动时，可以把它看成是一个刚体，刚体上有一个万向支点，而陀螺可以绕着这个支点作三个自由度的转动，所以陀螺的运动是属于刚体绕一个定点的转动运动。更确切地说，一个绕对称铀高速旋转的飞轮转子叫陀螺。将陀螺安装在框架装置上，使陀螺的自转轴有角转动的自由度，这种装置的总体叫做陀螺仪。<br>陀螺仪的原理就是，一个旋转物体的旋转轴所指的方向在不受外力影响时，是不会改变的。人们根据这个道理，用它来保持方向，制造出来的东西就叫陀螺仪。我们骑自行车其实也是利用了这个原理。轮子转得越快越不容易倒，因为车轴有一股保持水平的力量。陀螺仪在工作时要给它一个力，使它快速旋转起来，一般能达到每分钟几十万转，可以工作很长时间。然后用多种方法读取轴所指示的方向，并自动将数据信号传给控制系统。</p><h1 id="Ⅱ-MPU6050模块"><a href="#Ⅱ-MPU6050模块" class="headerlink" title="Ⅱ.MPU6050模块"></a>Ⅱ.MPU6050模块</h1><p>简介：<br>MPU6050内部整合了<strong>三轴MEMS陀螺仪</strong>、<strong>三轴MEMS加速度计</strong>以及一个可扩展的<strong>数字运动处理器DMP(Digital Motion Processor)<strong>，而且还可以连接一个第三方数字传感器(如磁力计)，这样的话，就可以通过IIC接口输出一个9轴信号(链接第三方数字传感器才可以输出九轴信号，否则只有六轴信号)。更加方便的是，有了DMP，可以结合InvenSense公司提供的运动处理资料库，实现姿态解算。通过自带的DMP，可以通过</strong>IIC接口</strong>输出9轴融合演算的数据，大大降低了运动处理运算对操作系统的负荷，同时也降低了开发难度。<em><strong>其实，简单一句话说，陀螺仪就是测角速度的，加速度传感器就是测角加速度的，二者数据通过算法就可以得到PITCH、YAW、ROLL角了。</strong></em></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20140401183456562" alt="右手笛卡尔坐标系"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20140401183518578"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20140401183525562"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20140401183537890"></p><p>特点：</p><ol><li>以数字形式输出 6 轴或 9 轴（需外接磁传感器）的旋转矩阵、四元数(quaternion)、欧拉角格式(Euler Angle forma)的融合演算数据（需 DMP 支持）</li><li>具有 131 LSBs/° /sec 敏感度与全格感测范围为±250、±500、±1000 与±2000° /sec的 3 轴角速度感测器(陀螺仪)</li><li>集成可程序控制，范围为±2g、±4g、±8g 和±16g 的 3 轴加速度传感器</li><li>移除加速器与陀螺仪轴间敏感度，降低设定给予的影响与感测器的飘移</li><li>自带数字运动处理(DMP: Digital Motion Processing)引擎可减少 MCU 复杂的融合演算数据、感测器同步化、姿势感应等的负荷</li><li>内建运作时间偏差与磁力感测器校正演算技术，免除了客户须另外进行校正的需求</li><li>自带一个数字温度传感器</li><li>带数字输入同步引脚(Sync pin)支持视频电子影相稳定技术与 GPS</li><li>可程序控制的中断(interrupt)，支持姿势识别、摇摄、画面放大缩小、滚动、快速下降中断、 high-G 中断、零动作感应、触击感应、摇动感应功能</li><li>VDD 供电电压为 2.5V±5%、 3.0V±5%、 3.3V±5%； VLOGIC 可低至 1.8V± 5%</li><li>陀螺仪工作电流： 5mA，陀螺仪待机电流： 5uA； 加速器工作电流：500uA，加速器省电模式电流： 40uA@10Hz</li><li>自带 1024 字节 FIFO，有助于降低系统功耗</li><li>高达 400Khz 的 IIC 通信接口</li><li>超小封装尺寸： 4x4x0.9mm（QFN）</li></ol><p>MPU6050三轴角(姿态角)<br><img src="https://img-blog.csdnimg.cn/20210527164308375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpaGFvdGlhbjExMQ==,size_16,color_FFFFFF,t_70#pic_center"><br><strong>绕向即为正方向，可根据右手螺旋定则确定方向。</strong><br>MPU6050框图：<br><img src="https://img-blog.csdnimg.cn/20210527152447545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpaGFvdGlhbjExMQ==,size_16,color_FFFFFF,t_70#pic_center">可以很清晰地观察到，MPU6050芯片中内置了三轴加速度传感器、三轴陀螺仪和一个温度传感器。右侧INT为中断输出脚，TCS为片选脚、AD0为设置地址脚、SCL和SDA为主IIC接口、AUX_CL和AUX_DA为从IIC接口，主要用到的是AD0、SCL、SDA。</p><p>相关寄存器(想深入了解的朋友可以看一下)结合后面的代码更容易理解一些<br>①<br><img src="https://img-blog.csdnimg.cn/20210527153154426.jpg#pic_center"><br>DEVICE_RESE=1，复位MPU6050，复位完成后，自动清零。SLEEP=1，进入睡眠模式；SLEEP=0，正常工作模式。TEMP_DIS，用于设置是否使能温度传感器，设置为0，则使能CLKSEL[2:0]，用于选择系统时钟源，如下所示：</p><table><thead><tr><th>CLKSEL[2:0]</th><th>时钟源</th></tr></thead><tbody><tr><td>001</td><td>内部8M RC晶振</td></tr><tr><td>010</td><td>PLL，使用X轴陀螺作为参考</td></tr><tr><td>011</td><td>PLL，使用Y轴陀螺作为参考</td></tr><tr><td>100</td><td>PLL，使用Z轴陀螺作为参考</td></tr><tr><td>101</td><td>PLL，使用外部32.768Khz作为参考</td></tr><tr><td>110</td><td>PLL，使用外部19.2Mhz作为参考</td></tr><tr><td>11</td><td>保留</td></tr><tr><td>001</td><td>关闭时钟，保持时序产生电路复位状态</td></tr></tbody></table><p>总之，电源管理寄存器就是复位MPU6050<br>②<br><img src="https://img-blog.csdnimg.cn/20210527154441137.jpg#pic_center"><br>该寄存器我们只关心FS_SEL[1:0]这两个位，用于设置陀螺仪的满量程范围：0，±250°/s；1，±500°/s；2，±1000°/s；3，±2000°/s；我们一般设置为3，即±2000°/S，因为陀螺仪的ADC为16位分辨率，所以得到灵敏度为：65536/4000=16.4LSB/(°/S)。<br>总之，陀螺仪配置寄存器就是配置陀螺仪满量程范围，设置最大<br>③<br><img src="https://img-blog.csdnimg.cn/20210527154625454.jpg#pic_center"><br>该寄存器我们只关心AFS_SEL[1:0]这两个位，用于设置加速度传感器的满量程范围：0，±2g；1，±4g；2，±8g；3，±16g；我们一般设置为0，即±2g，因为加速度传感器的ADC也是16位，所以得到灵敏度为：65536/4=16384LSB/g。<br>总之，加速度传感器配置寄存器就是配置加速度传感器满量程范围，不宜过大<br>④<br><img src="https://img-blog.csdnimg.cn/20210527154801757.jpg#pic_center"><br>该寄存器用于控制FIFO使能，在简单读取传感器数据的时候，可以不用FIFO，设置对应位为：0，即可禁止FIFO，设置为1，则使能FIFO。加速度传感器的三个轴，全由一个位(ACCEL_FIFO_EN)控制，只要该位为1，则加速度传感器三个通道都开启FIFO；但是陀螺仪传感器的三个轴需要一个一个设置，即XYZ轴分别配置。<br>总之，FIFO使能寄存器用于控制使能FIFO(First Input First Output)<br>⑤<br><img src="https://img-blog.csdnimg.cn/20210527160414156.jpg#pic_center"><br>该寄存器用于设置MPU6050的陀螺仪采样频率，计算公式为：**采样频率 = 陀螺仪输出频率 / (1+SMPLRT_DIV)**。这里陀螺仪的输出频率，是1Khz或者8Khz，与数字低通滤波器（DLPF）的设置有关，当DLPF_CFG=0或7的时候，频率为8Khz，其他情况是1Khz。而且DLPF滤波频率一般设置为采样率的一半。采样率，我们假定设置为50Hz，那么：SMPLRT_DIV=1000/50-1=19。<br>总之，陀螺仪采样率分频寄存器就是用于设置陀螺仪的采样频率，如果采样频率为50Hz，那么采样周期就为1/50=20ms，即20ms采集一次陀螺仪的数据。<br>⑥<br><img src="https://img-blog.csdnimg.cn/20210527160935948.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpaGFvdGlhbjExMQ==,size_16,color_FFFFFF,t_70#pic_center"><br>总之，配置寄存器就是设置数字低通滤波器的DLPF_CFG位来结合陀螺仪采样分频寄存器来共同设置采样周期。<br>⑦<br><img src="https://img-blog.csdnimg.cn/20210527162315369.jpg#pic_center"><br>该寄存器的LP_WAKE_CTRL用于控制低功耗时的唤醒频率，用不到。剩下的6位，分别控制加速度和陀螺仪的x/y/z轴是否进入待机模式，这里我们全部都不进入待机模式，所以全部设置为：0 ，即可。<br>总之，电源管理寄存器2就是用于设置加速度传感器和陀螺仪的X/Y/Z轴是进入休眠还是正常工作。<br>⑧<img src="https://img-blog.csdnimg.cn/20210527162507349.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpaGFvdGlhbjExMQ==,size_16,color_FFFFFF,t_70#pic_center"><br>加速度传感器数据输出寄存器总共由6个寄存器组成，输出X/Y/Z三个轴的加速度传感器值，高字节在前，低字节在后。<br>总之，加速度传感器数据输出寄存器就是把加速度传感器测量到的数据输出出来。<br>⑨<br><img src="https://img-blog.csdnimg.cn/2021052716305611.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpaGFvdGlhbjExMQ==,size_16,color_FFFFFF,t_70#pic_center"><br>陀螺仪数据输出寄存器总共由6个寄存器组成，输出X/Y/Z三个轴的陀螺仪传感器数据，高字节在前，低字节在后。<br>总之，陀螺仪数据输出寄存器就是把陀螺仪测量到的数据输出出来。<br>⑩<br><img src="https://img-blog.csdnimg.cn/20210527163838510.jpg#pic_center"><br>通过读取0X41（高8位）和0X42（低8位)寄存器得到，温度换算公式为：<br>Temperature = 36.53 + regval/340。其中，Temperature为计算得到的温度值，单位为℃，regval为从0X41和0X42读到的温度传感器值。<br>总之，温度传感器数据输出寄存器就是把温度寄存器测量到的数据处处出来。</p><h1 id="3-硬件连接"><a href="#3-硬件连接" class="headerlink" title="3.硬件连接"></a>3.硬件连接</h1><p><img src="https://img-blog.csdnimg.cn/20210527164235503.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpaGFvdGlhbjExMQ==,size_16,color_FFFFFF,t_70#pic_center"><br><strong>VCC</strong>:接5V电源<br><strong>GND</strong>:接地<br><strong>SCL</strong>:主IIC时钟线 (我接的PB10)<br><strong>SDA</strong>:主IIC数据线 (我接的PB11)<br><strong>AD0</strong>:地址线，接3V地址为0x68，接地地址为0x69（我接的PA15，高电平，地址为0x68)</p><h1 id="4-软件代码————官方自带库"><a href="#4-软件代码————官方自带库" class="headerlink" title="4.软件代码————官方自带库"></a>4.软件代码————官方自带库</h1><p>MPU6050处理寄存器的相关数据时需要移植几个官方库，以便将数据处理为所需要的欧拉角。正点原子共提供了五个源码，如下图：<br><img src="https://img-blog.csdnimg.cn/20210527171530241.jpg#pic_center"><br>这些是需要在写MPU6050代码之前移植过来的，具体代码内容大家可以下载下方源码查看。</p><h1 id="5-软件代码————其他代码"><a href="#5-软件代码————其他代码" class="headerlink" title="5.软件代码————其他代码"></a>5.软件代码————其他代码</h1><p>MPU6050.h<br><strong>主要宏定义一些MPU6050寄存器的地址，方便IIC发送给寄存器数据初始化MPU6050。</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__MPU6050_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__MPU6050_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mpuiic.h"</span>       </span> <span class="token comment">//MPU6050 AD0控制脚</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_AD0_CTRL</span><span class="token expression"><span class="token function">PAout</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span></span><span class="token comment">//控制AD0电平,从而控制MPU地址</span></span><span class="token comment">//#define MPU_ACCEL_OFFS_REG0X06//accel_offs寄存器,可读取版本号,寄存器手册未提到</span><span class="token comment">//#define MPU_PROD_ID_REG0X0C//prod id寄存器,在寄存器手册未提到</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_SELF_TESTX_REG</span><span class="token expression"><span class="token number">0X0D</span></span><span class="token comment">//自检寄存器X</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_SELF_TESTY_REG</span><span class="token expression"><span class="token number">0X0E</span></span><span class="token comment">//自检寄存器Y</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_SELF_TESTZ_REG</span><span class="token expression"><span class="token number">0X0F</span></span><span class="token comment">//自检寄存器Z</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_SELF_TESTA_REG</span><span class="token expression"><span class="token number">0X10</span></span><span class="token comment">//自检寄存器A</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_SAMPLE_RATE_REG</span><span class="token expression"><span class="token number">0X19</span></span><span class="token comment">//采样频率分频器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_CFG_REG</span><span class="token expression"><span class="token number">0X1A</span></span><span class="token comment">//配置寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_GYRO_CFG_REG</span><span class="token expression"><span class="token number">0X1B</span></span><span class="token comment">//陀螺仪配置寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_ACCEL_CFG_REG</span><span class="token expression"><span class="token number">0X1C</span></span><span class="token comment">//加速度计配置寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_MOTION_DET_REG</span><span class="token expression"><span class="token number">0X1F</span></span><span class="token comment">//运动检测阀值设置寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_FIFO_EN_REG</span><span class="token expression"><span class="token number">0X23</span></span><span class="token comment">//FIFO使能寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CMST_CTRL_REG</span><span class="token expression"><span class="token number">0X24</span></span><span class="token comment">//IIC主机控制寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CSLV0_ADDR_REG</span><span class="token expression"><span class="token number">0X25</span></span><span class="token comment">//IIC从机0器件地址寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CSLV0_REG</span><span class="token expression"><span class="token number">0X26</span></span><span class="token comment">//IIC从机0数据地址寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CSLV0_CTRL_REG</span><span class="token expression"><span class="token number">0X27</span></span><span class="token comment">//IIC从机0控制寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CSLV1_ADDR_REG</span><span class="token expression"><span class="token number">0X28</span></span><span class="token comment">//IIC从机1器件地址寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CSLV1_REG</span><span class="token expression"><span class="token number">0X29</span></span><span class="token comment">//IIC从机1数据地址寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CSLV1_CTRL_REG</span><span class="token expression"><span class="token number">0X2A</span></span><span class="token comment">//IIC从机1控制寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CSLV2_ADDR_REG</span><span class="token expression"><span class="token number">0X2B</span></span><span class="token comment">//IIC从机2器件地址寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CSLV2_REG</span><span class="token expression"><span class="token number">0X2C</span></span><span class="token comment">//IIC从机2数据地址寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CSLV2_CTRL_REG</span><span class="token expression"><span class="token number">0X2D</span></span><span class="token comment">//IIC从机2控制寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CSLV3_ADDR_REG</span><span class="token expression"><span class="token number">0X2E</span></span><span class="token comment">//IIC从机3器件地址寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CSLV3_REG</span><span class="token expression"><span class="token number">0X2F</span></span><span class="token comment">//IIC从机3数据地址寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CSLV3_CTRL_REG</span><span class="token expression"><span class="token number">0X30</span></span><span class="token comment">//IIC从机3控制寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CSLV4_ADDR_REG</span><span class="token expression"><span class="token number">0X31</span></span><span class="token comment">//IIC从机4器件地址寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CSLV4_REG</span><span class="token expression"><span class="token number">0X32</span></span><span class="token comment">//IIC从机4数据地址寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CSLV4_DO_REG</span><span class="token expression"><span class="token number">0X33</span></span><span class="token comment">//IIC从机4写数据寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CSLV4_CTRL_REG</span><span class="token expression"><span class="token number">0X34</span></span><span class="token comment">//IIC从机4控制寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CSLV4_DI_REG</span><span class="token expression"><span class="token number">0X35</span></span><span class="token comment">//IIC从机4读数据寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CMST_STA_REG</span><span class="token expression"><span class="token number">0X36</span></span><span class="token comment">//IIC主机状态寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_INTBP_CFG_REG</span><span class="token expression"><span class="token number">0X37</span></span><span class="token comment">//中断/旁路设置寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_INT_EN_REG</span><span class="token expression"><span class="token number">0X38</span></span><span class="token comment">//中断使能寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_INT_STA_REG</span><span class="token expression"><span class="token number">0X3A</span></span><span class="token comment">//中断状态寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_ACCEL_XOUTH_REG</span><span class="token expression"><span class="token number">0X3B</span></span><span class="token comment">//加速度值,X轴高8位寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_ACCEL_XOUTL_REG</span><span class="token expression"><span class="token number">0X3C</span></span><span class="token comment">//加速度值,X轴低8位寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_ACCEL_YOUTH_REG</span><span class="token expression"><span class="token number">0X3D</span></span><span class="token comment">//加速度值,Y轴高8位寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_ACCEL_YOUTL_REG</span><span class="token expression"><span class="token number">0X3E</span></span><span class="token comment">//加速度值,Y轴低8位寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_ACCEL_ZOUTH_REG</span><span class="token expression"><span class="token number">0X3F</span></span><span class="token comment">//加速度值,Z轴高8位寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_ACCEL_ZOUTL_REG</span><span class="token expression"><span class="token number">0X40</span></span><span class="token comment">//加速度值,Z轴低8位寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_TEMP_OUTH_REG</span><span class="token expression"><span class="token number">0X41</span></span><span class="token comment">//温度值高八位寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_TEMP_OUTL_REG</span><span class="token expression"><span class="token number">0X42</span></span><span class="token comment">//温度值低8位寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_GYRO_XOUTH_REG</span><span class="token expression"><span class="token number">0X43</span></span><span class="token comment">//陀螺仪值,X轴高8位寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_GYRO_XOUTL_REG</span><span class="token expression"><span class="token number">0X44</span></span><span class="token comment">//陀螺仪值,X轴低8位寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_GYRO_YOUTH_REG</span><span class="token expression"><span class="token number">0X45</span></span><span class="token comment">//陀螺仪值,Y轴高8位寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_GYRO_YOUTL_REG</span><span class="token expression"><span class="token number">0X46</span></span><span class="token comment">//陀螺仪值,Y轴低8位寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_GYRO_ZOUTH_REG</span><span class="token expression"><span class="token number">0X47</span></span><span class="token comment">//陀螺仪值,Z轴高8位寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_GYRO_ZOUTL_REG</span><span class="token expression"><span class="token number">0X48</span></span><span class="token comment">//陀螺仪值,Z轴低8位寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CSLV0_DO_REG</span><span class="token expression"><span class="token number">0X63</span></span><span class="token comment">//IIC从机0数据寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CSLV1_DO_REG</span><span class="token expression"><span class="token number">0X64</span></span><span class="token comment">//IIC从机1数据寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CSLV2_DO_REG</span><span class="token expression"><span class="token number">0X65</span></span><span class="token comment">//IIC从机2数据寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CSLV3_DO_REG</span><span class="token expression"><span class="token number">0X66</span></span><span class="token comment">//IIC从机3数据寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_I2CMST_DELAY_REG</span><span class="token expression"><span class="token number">0X67</span></span><span class="token comment">//IIC主机延时管理寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_SIGPATH_RST_REG</span><span class="token expression"><span class="token number">0X68</span></span><span class="token comment">//信号通道复位寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_MDETECT_CTRL_REG</span><span class="token expression"><span class="token number">0X69</span></span><span class="token comment">//运动检测控制寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_USER_CTRL_REG</span><span class="token expression"><span class="token number">0X6A</span></span><span class="token comment">//用户控制寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_PWR_MGMT1_REG</span><span class="token expression"><span class="token number">0X6B</span></span><span class="token comment">//电源管理寄存器1</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_PWR_MGMT2_REG</span><span class="token expression"><span class="token number">0X6C</span></span><span class="token comment">//电源管理寄存器2 </span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_FIFO_CNTH_REG</span><span class="token expression"><span class="token number">0X72</span></span><span class="token comment">//FIFO计数寄存器高八位</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_FIFO_CNTL_REG</span><span class="token expression"><span class="token number">0X73</span></span><span class="token comment">//FIFO计数寄存器低八位</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_FIFO_RW_REG</span><span class="token expression"><span class="token number">0X74</span></span><span class="token comment">//FIFO读写寄存器</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_DEVICE_ID_REG</span><span class="token expression"><span class="token number">0X75</span></span><span class="token comment">//器件ID寄存器</span></span> <span class="token comment">//如果AD0脚(9脚)接地,IIC地址为0X68(不包含最低位).</span><span class="token comment">//如果接V3.3,则IIC地址为0X69(不包含最低位).</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_ADDR</span><span class="token expression"><span class="token number">0X68</span></span></span><span class="token comment">//因为模块AD0默认接GND,所以转为读写地址后,为0XD1和0XD0(如果接VCC,则为0XD3和0XD2)  </span><span class="token comment">//#define MPU_READ    0XD1</span><span class="token comment">//#define MPU_WRITE   0XD0</span>u8 <span class="token function">MPU_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//初始化MPU6050</span>u8 <span class="token function">MPU_Write_Len</span><span class="token punctuation">(</span>u8 addr<span class="token punctuation">,</span>u8 reg<span class="token punctuation">,</span>u8 len<span class="token punctuation">,</span>u8 <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//IIC连续写</span>u8 <span class="token function">MPU_Read_Len</span><span class="token punctuation">(</span>u8 addr<span class="token punctuation">,</span>u8 reg<span class="token punctuation">,</span>u8 len<span class="token punctuation">,</span>u8 <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//IIC连续读 </span>u8 <span class="token function">MPU_Write_Byte</span><span class="token punctuation">(</span>u8 reg<span class="token punctuation">,</span>u8 data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//IIC写一个字节</span>u8 <span class="token function">MPU_Read_Byte</span><span class="token punctuation">(</span>u8 reg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//IIC读一个字节</span>u8 <span class="token function">MPU_Set_Gyro_Fsr</span><span class="token punctuation">(</span>u8 fsr<span class="token punctuation">)</span><span class="token punctuation">;</span>u8 <span class="token function">MPU_Set_Accel_Fsr</span><span class="token punctuation">(</span>u8 fsr<span class="token punctuation">)</span><span class="token punctuation">;</span>u8 <span class="token function">MPU_Set_LPF</span><span class="token punctuation">(</span>u16 lpf<span class="token punctuation">)</span><span class="token punctuation">;</span>u8 <span class="token function">MPU_Set_Rate</span><span class="token punctuation">(</span>u16 rate<span class="token punctuation">)</span><span class="token punctuation">;</span>u8 <span class="token function">MPU_Set_Fifo</span><span class="token punctuation">(</span>u8 sens<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">short</span> <span class="token function">MPU_Get_Temperature</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>u8 <span class="token function">MPU_Get_Gyroscope</span><span class="token punctuation">(</span><span class="token keyword">short</span> <span class="token operator">*</span>gx<span class="token punctuation">,</span><span class="token keyword">short</span> <span class="token operator">*</span>gy<span class="token punctuation">,</span><span class="token keyword">short</span> <span class="token operator">*</span>gz<span class="token punctuation">)</span><span class="token punctuation">;</span>u8 <span class="token function">MPU_Get_Accelerometer</span><span class="token punctuation">(</span><span class="token keyword">short</span> <span class="token operator">*</span>ax<span class="token punctuation">,</span><span class="token keyword">short</span> <span class="token operator">*</span>ay<span class="token punctuation">,</span><span class="token keyword">short</span> <span class="token operator">*</span>az<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MPU6050.c<br><strong>主要是单片机通过IIC协议向MPU6050写数据读数据的函数以及MPU6050初始化函数</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mpu6050.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"sys.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"delay.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"usart.h"</span>   </span><span class="token comment">/**********************************************函数名称：MPU_Init函数功能：初始化MPU6050函数参数：无函数返回值：0,初始化成功  其他,初始化失败**********************************************/</span>u8 <span class="token function">MPU_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span> u8 res<span class="token punctuation">;</span>  GPIO_InitTypeDef  GPIO_InitStructure<span class="token punctuation">;</span><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_AFIO<span class="token punctuation">,</span>ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使能AFIO时钟 </span><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span>ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先使能外设IO PORTA时钟 </span>  GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_15<span class="token punctuation">;</span>  <span class="token comment">//端口配置</span>  GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_Out_PP<span class="token punctuation">;</span>  <span class="token comment">//推挽输出</span>  GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>  <span class="token comment">//IO口速度为50MHz</span>  <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//根据设定参数初始化GPIOA</span><span class="token function">GPIO_PinRemapConfig</span><span class="token punctuation">(</span>GPIO_Remap_SWJ_JTAGDisable<span class="token punctuation">,</span>ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//禁止JTAG,从而PA15可以做普通IO使用,否则PA15不能做普通IO!!!</span>MPU_AD0_CTRL<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//控制MPU6050的AD0脚为低电平,从机地址为:0X68</span><span class="token function">MPU_IIC_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化IIC总线</span><span class="token function">MPU_Write_Byte</span><span class="token punctuation">(</span>MPU_PWR_MGMT1_REG<span class="token punctuation">,</span><span class="token number">0X80</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//复位MPU6050</span>  <span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MPU_Write_Byte</span><span class="token punctuation">(</span>MPU_PWR_MGMT1_REG<span class="token punctuation">,</span><span class="token number">0X00</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//唤醒MPU6050 </span><span class="token function">MPU_Set_Gyro_Fsr</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//陀螺仪传感器,±2000dps</span><span class="token function">MPU_Set_Accel_Fsr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加速度传感器,±2g</span><span class="token function">MPU_Set_Rate</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置采样率50Hz</span><span class="token function">MPU_Write_Byte</span><span class="token punctuation">(</span>MPU_INT_EN_REG<span class="token punctuation">,</span><span class="token number">0X00</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//关闭所有中断</span><span class="token function">MPU_Write_Byte</span><span class="token punctuation">(</span>MPU_USER_CTRL_REG<span class="token punctuation">,</span><span class="token number">0X00</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//I2C主模式关闭</span><span class="token function">MPU_Write_Byte</span><span class="token punctuation">(</span>MPU_FIFO_EN_REG<span class="token punctuation">,</span><span class="token number">0X00</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//关闭FIFO</span><span class="token function">MPU_Write_Byte</span><span class="token punctuation">(</span>MPU_INTBP_CFG_REG<span class="token punctuation">,</span><span class="token number">0X80</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//INT引脚低电平有效</span>res<span class="token operator">=</span><span class="token function">MPU_Read_Byte</span><span class="token punctuation">(</span>MPU_DEVICE_ID_REG<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token operator">==</span>MPU_ADDR<span class="token punctuation">)</span><span class="token comment">//器件ID正确,即res = MPU_ADDR = 0x68</span><span class="token punctuation">{</span><span class="token function">MPU_Write_Byte</span><span class="token punctuation">(</span>MPU_PWR_MGMT1_REG<span class="token punctuation">,</span><span class="token number">0X01</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置CLKSEL,PLL X轴为参考</span><span class="token function">MPU_Write_Byte</span><span class="token punctuation">(</span>MPU_PWR_MGMT2_REG<span class="token punctuation">,</span><span class="token number">0X00</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加速度与陀螺仪都工作</span><span class="token function">MPU_Set_Rate</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置采样率为50Hz</span> <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//地址设置错误,返回1</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//地址设置正确,返回0</span><span class="token punctuation">}</span><span class="token comment">/**********************************************函数名称：MPU_Set_Gyro_Fsr函数功能：设置MPU6050陀螺仪传感器满量程范围函数参数：fsr:0,±250dps;1,±500dps;2,±1000dps;3,±2000dps函数返回值：0,设置成功  其他,设置失败**********************************************/</span>u8 <span class="token function">MPU_Set_Gyro_Fsr</span><span class="token punctuation">(</span>u8 fsr<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">MPU_Write_Byte</span><span class="token punctuation">(</span>MPU_GYRO_CFG_REG<span class="token punctuation">,</span>fsr<span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设置陀螺仪满量程范围</span><span class="token punctuation">}</span><span class="token comment">/**********************************************函数名称：MPU_Set_Accel_Fsr函数功能：设置MPU6050加速度传感器满量程范围函数参数：fsr:0,±2g;1,±4g;2,±8g;3,±16g函数返回值：0,设置成功  其他,设置失败**********************************************/</span>u8 <span class="token function">MPU_Set_Accel_Fsr</span><span class="token punctuation">(</span>u8 fsr<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">MPU_Write_Byte</span><span class="token punctuation">(</span>MPU_ACCEL_CFG_REG<span class="token punctuation">,</span>fsr<span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设置加速度传感器满量程范围  </span><span class="token punctuation">}</span><span class="token comment">/**********************************************函数名称：MPU_Set_LPF函数功能：设置MPU6050的数字低通滤波器函数参数：lpf:数字低通滤波频率(Hz)函数返回值：0,设置成功  其他,设置失败**********************************************/</span>u8 <span class="token function">MPU_Set_LPF</span><span class="token punctuation">(</span>u16 lpf<span class="token punctuation">)</span><span class="token punctuation">{</span>u8 data<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>lpf<span class="token operator">&gt;=</span><span class="token number">188</span><span class="token punctuation">)</span>data<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>lpf<span class="token operator">&gt;=</span><span class="token number">98</span><span class="token punctuation">)</span>data<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>lpf<span class="token operator">&gt;=</span><span class="token number">42</span><span class="token punctuation">)</span>data<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>lpf<span class="token operator">&gt;=</span><span class="token number">20</span><span class="token punctuation">)</span>data<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>lpf<span class="token operator">&gt;=</span><span class="token number">10</span><span class="token punctuation">)</span>data<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">else</span> data<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token function">MPU_Write_Byte</span><span class="token punctuation">(</span>MPU_CFG_REG<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置数字低通滤波器  </span><span class="token punctuation">}</span><span class="token comment">/**********************************************函数名称：MPU_Set_Rate函数功能：设置MPU6050的采样率(假定Fs=1KHz)函数参数：rate:4~1000(Hz)  初始化中rate取50函数返回值：0,设置成功  其他,设置失败**********************************************/</span>u8 <span class="token function">MPU_Set_Rate</span><span class="token punctuation">(</span>u16 rate<span class="token punctuation">)</span><span class="token punctuation">{</span>u8 data<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>rate<span class="token operator">&gt;</span><span class="token number">1000</span><span class="token punctuation">)</span>rate<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>rate<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">)</span>rate<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>data<span class="token operator">=</span><span class="token number">1000</span><span class="token operator">/</span>rate<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>data<span class="token operator">=</span><span class="token function">MPU_Write_Byte</span><span class="token punctuation">(</span>MPU_SAMPLE_RATE_REG<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置数字低通滤波器</span> <span class="token keyword">return</span> <span class="token function">MPU_Set_LPF</span><span class="token punctuation">(</span>rate<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自动设置LPF为采样率的一半</span><span class="token punctuation">}</span><span class="token comment">/**********************************************函数名称：MPU_Get_Temperature函数功能：得到温度传感器值函数参数：无函数返回值：温度值(扩大了100倍)**********************************************/</span><span class="token keyword">short</span> <span class="token function">MPU_Get_Temperature</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   u8 buf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">short</span> raw<span class="token punctuation">;</span> <span class="token keyword">float</span> temp<span class="token punctuation">;</span> <span class="token function">MPU_Read_Len</span><span class="token punctuation">(</span>MPU_ADDR<span class="token punctuation">,</span>MPU_TEMP_OUTH_REG<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    raw<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>u16<span class="token punctuation">)</span>buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">|</span>buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   temp<span class="token operator">=</span><span class="token number">36.53</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>raw<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">340</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> temp<span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/**********************************************函数名称：MPU_Get_Gyroscope函数功能：得到陀螺仪值(原始值)函数参数：gx,gy,gz:陀螺仪x,y,z轴的原始读数(带符号)函数返回值：0,读取成功  其他,读取失败**********************************************/</span>u8 <span class="token function">MPU_Get_Gyroscope</span><span class="token punctuation">(</span><span class="token keyword">short</span> <span class="token operator">*</span>gx<span class="token punctuation">,</span><span class="token keyword">short</span> <span class="token operator">*</span>gy<span class="token punctuation">,</span><span class="token keyword">short</span> <span class="token operator">*</span>gz<span class="token punctuation">)</span><span class="token punctuation">{</span>  u8 buf<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span>res<span class="token punctuation">;</span>res<span class="token operator">=</span><span class="token function">MPU_Read_Len</span><span class="token punctuation">(</span>MPU_ADDR<span class="token punctuation">,</span>MPU_GYRO_XOUTH_REG<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">*</span>gx<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>u16<span class="token punctuation">)</span>buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">|</span>buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token operator">*</span>gy<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>u16<span class="token punctuation">)</span>buf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">|</span>buf<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token operator">*</span>gz<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>u16<span class="token punctuation">)</span>buf<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">|</span>buf<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>   <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/**********************************************函数名称：MPU_Get_Accelerometer函数功能：得到加速度值(原始值)函数参数：ax,ay,az:加速度传感器x,y,z轴的原始读数(带符号)函数返回值：0,读取成功  其他,读取失败**********************************************/</span>u8 <span class="token function">MPU_Get_Accelerometer</span><span class="token punctuation">(</span><span class="token keyword">short</span> <span class="token operator">*</span>ax<span class="token punctuation">,</span><span class="token keyword">short</span> <span class="token operator">*</span>ay<span class="token punctuation">,</span><span class="token keyword">short</span> <span class="token operator">*</span>az<span class="token punctuation">)</span><span class="token punctuation">{</span>    u8 buf<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span>res<span class="token punctuation">;</span>  res<span class="token operator">=</span><span class="token function">MPU_Read_Len</span><span class="token punctuation">(</span>MPU_ADDR<span class="token punctuation">,</span>MPU_ACCEL_XOUTH_REG<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">*</span>ax<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>u16<span class="token punctuation">)</span>buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">|</span>buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token operator">*</span>ay<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>u16<span class="token punctuation">)</span>buf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">|</span>buf<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token operator">*</span>az<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>u16<span class="token punctuation">)</span>buf<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">|</span>buf<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>     <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/**********************************************函数名称：MPU_Write_Len函数功能：IIC连续写(写器件地址、寄存器地址、数据)函数参数：addr:器件地址      reg:寄存器地址 len:写入数据的长度  buf:数据区函数返回值：0,写入成功  其他,写入失败**********************************************/</span>u8 <span class="token function">MPU_Write_Len</span><span class="token punctuation">(</span>u8 addr<span class="token punctuation">,</span>u8 reg<span class="token punctuation">,</span>u8 len<span class="token punctuation">,</span>u8 <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">{</span>u8 i<span class="token punctuation">;</span><span class="token function">MPU_IIC_Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MPU_IIC_Send_Byte</span><span class="token punctuation">(</span><span class="token punctuation">(</span>addr<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//发送器件地址+写命令(0为写,1为读)</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">MPU_IIC_Wait_Ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//等待应答</span><span class="token punctuation">{</span><span class="token function">MPU_IIC_Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token function">MPU_IIC_Send_Byte</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//写寄存器地址</span>    <span class="token function">MPU_IIC_Wait_Ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">//等待应答</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">MPU_IIC_Send_Byte</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//发送数据</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">MPU_IIC_Wait_Ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token comment">//等待ACK</span><span class="token punctuation">{</span><span class="token function">MPU_IIC_Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token function">MPU_IIC_Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/**********************************************函数名称：MPU_Read_Len函数功能：IIC连续读(写入器件地址后,读寄存器地址、数据)函数参数：addr:器件地址        reg:要读的寄存器地址 len:要读取的数据长度  buf:读取到的数据存储区函数返回值：0,读取成功  其他,读取失败**********************************************/</span>u8 <span class="token function">MPU_Read_Len</span><span class="token punctuation">(</span>u8 addr<span class="token punctuation">,</span>u8 reg<span class="token punctuation">,</span>u8 len<span class="token punctuation">,</span>u8 <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">MPU_IIC_Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MPU_IIC_Send_Byte</span><span class="token punctuation">(</span><span class="token punctuation">(</span>addr<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//发送器件地址+写命令</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">MPU_IIC_Wait_Ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//等待应答</span><span class="token punctuation">{</span><span class="token function">MPU_IIC_Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token function">MPU_IIC_Send_Byte</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//写寄存器地址</span>    <span class="token function">MPU_IIC_Wait_Ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等待应答</span>    <span class="token function">MPU_IIC_Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MPU_IIC_Send_Byte</span><span class="token punctuation">(</span><span class="token punctuation">(</span>addr<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//发送器件地址+读命令</span>    <span class="token function">MPU_IIC_Wait_Ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等待应答 </span><span class="token keyword">while</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span>buf<span class="token operator">=</span><span class="token function">MPU_IIC_Read_Byte</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//读数据,发送nACK </span><span class="token keyword">else</span>  <span class="token operator">*</span>buf<span class="token operator">=</span><span class="token function">MPU_IIC_Read_Byte</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//读数据,发送ACK  </span>len<span class="token operator">--</span><span class="token punctuation">;</span>buf<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token function">MPU_IIC_Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//产生一个停止条件 </span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/**********************************************函数名称：MPU_Write_Byte函数功能：IIC写一个字节函数参数：data:写入的数据    reg:要写的寄存器地址函数返回值：0,写入成功  其他,写入失败**********************************************/</span>u8 <span class="token function">MPU_Write_Byte</span><span class="token punctuation">(</span>u8 reg<span class="token punctuation">,</span>u8 data<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">MPU_IIC_Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MPU_IIC_Send_Byte</span><span class="token punctuation">(</span><span class="token punctuation">(</span>MPU_ADDR<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//发送器件地址+写命令</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">MPU_IIC_Wait_Ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//等待应答</span><span class="token punctuation">{</span><span class="token function">MPU_IIC_Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token function">MPU_IIC_Send_Byte</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//写寄存器地址</span>  <span class="token function">MPU_IIC_Wait_Ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等待应答</span><span class="token function">MPU_IIC_Send_Byte</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//发送数据</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">MPU_IIC_Wait_Ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">//等待ACK</span><span class="token punctuation">{</span><span class="token function">MPU_IIC_Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token function">MPU_IIC_Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/**********************************************函数名称：MPU_Read_Byte函数功能：IIC读一个字节函数参数：reg:要读的寄存器地址函数返回值：res:读取到的数据**********************************************/</span>u8 <span class="token function">MPU_Read_Byte</span><span class="token punctuation">(</span>u8 reg<span class="token punctuation">)</span><span class="token punctuation">{</span>u8 res<span class="token punctuation">;</span>  <span class="token function">MPU_IIC_Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">MPU_IIC_Send_Byte</span><span class="token punctuation">(</span><span class="token punctuation">(</span>MPU_ADDR<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//发送器件地址+写命令</span><span class="token function">MPU_IIC_Wait_Ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等待应答 </span>  <span class="token function">MPU_IIC_Send_Byte</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//写寄存器地址</span>  <span class="token function">MPU_IIC_Wait_Ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等待应答</span>  <span class="token function">MPU_IIC_Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MPU_IIC_Send_Byte</span><span class="token punctuation">(</span><span class="token punctuation">(</span>MPU_ADDR<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//发送器件地址+读命令</span>  <span class="token function">MPU_IIC_Wait_Ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等待应答 </span>res<span class="token operator">=</span><span class="token function">MPU_IIC_Read_Byte</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//读取数据,发送nACK </span>  <span class="token function">MPU_IIC_Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//产生一个停止条件 </span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mpuiic.h<br><strong>MPU的IIC协议函数头文件，PB11为SDA，PB10为SCL。</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__MPUIIC_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__MPUIIC_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"sys.h"</span></span><span class="token comment">//IO方向设置  ---PB11</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MPU_SDA_IN</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>GPIOB<span class="token operator">-&gt;</span>CRH <span class="token operator">&amp;=</span> <span class="token number">0XFFFF0FFF</span><span class="token punctuation">;</span>GPIOB<span class="token operator">-&gt;</span>CRH <span class="token operator">|=</span> <span class="token number">8</span><span class="token operator">&lt;&lt;</span><span class="token number">12</span><span class="token punctuation">;</span><span class="token punctuation">}</span>   </span><span class="token comment">//上拉/下拉 输入模式</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MPU_SDA_OUT</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>GPIOB<span class="token operator">-&gt;</span>CRH <span class="token operator">&amp;=</span> <span class="token number">0XFFFF0FFF</span><span class="token punctuation">;</span>GPIOB<span class="token operator">-&gt;</span>CRH <span class="token operator">|=</span> <span class="token number">3</span><span class="token operator">&lt;&lt;</span><span class="token number">12</span><span class="token punctuation">;</span><span class="token punctuation">}</span></span><span class="token comment">//推挽输出  输出模式</span></span><span class="token comment">//IO操作函数 </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_IIC_SCL</span>    <span class="token expression"><span class="token function">PBout</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> </span><span class="token comment">//SCL</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_IIC_SDA</span>    <span class="token expression"><span class="token function">PBout</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> </span><span class="token comment">//SDA </span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MPU_READ_SDA</span>   <span class="token expression"><span class="token function">PBin</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> </span><span class="token comment">//输入SDA </span></span><span class="token comment">//IIC所有操作函数</span><span class="token keyword">void</span> <span class="token function">MPU_IIC_Delay</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//IIC延时2ms函数</span><span class="token keyword">void</span> <span class="token function">MPU_IIC_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//初始化IIC的IO口 </span><span class="token keyword">void</span> <span class="token function">MPU_IIC_Start</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//发送IIC开始信号</span><span class="token keyword">void</span> <span class="token function">MPU_IIC_Stop</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//发送IIC停止信号</span><span class="token keyword">void</span> <span class="token function">MPU_IIC_Send_Byte</span><span class="token punctuation">(</span>u8 txd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//IIC发送一个字节</span>u8 <span class="token function">MPU_IIC_Read_Byte</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> ack<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//IIC读取一个字节</span>u8 <span class="token function">MPU_IIC_Wait_Ack</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//IIC等待ACK信号</span><span class="token keyword">void</span> <span class="token function">MPU_IIC_Ack</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//IIC发送ACK信号</span><span class="token keyword">void</span> <span class="token function">MPU_IIC_NAck</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//IIC不发送ACK信号</span><span class="token keyword">void</span> <span class="token function">IMPU_IC_Write_One_Byte</span><span class="token punctuation">(</span>u8 daddr<span class="token punctuation">,</span>u8 addr<span class="token punctuation">,</span>u8 data<span class="token punctuation">)</span><span class="token punctuation">;</span>u8 <span class="token function">MPU_IIC_Read_One_Byte</span><span class="token punctuation">(</span>u8 daddr<span class="token punctuation">,</span>u8 addr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token number">1234567891011121314151617181920212223242526272829</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mpuiic.c<br><strong>MPU的IIC协议函数编写</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mpuiic.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"delay.h"</span></span> <span class="token comment">/**********************************************函数名称：MPU_IIC_Delay函数功能：MPU IIC延时函数，延时2ms函数参数：无函数返回值：无**********************************************/</span><span class="token keyword">void</span> <span class="token function">MPU_IIC_Delay</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">delay_us</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/**********************************************函数名称：MPU_IIC_Init函数功能：MPU IIC初始化函数参数：无函数返回值：无**********************************************/</span><span class="token keyword">void</span> <span class="token function">MPU_IIC_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       GPIO_InitTypeDef  GPIO_InitStructure<span class="token punctuation">;</span><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOB<span class="token punctuation">,</span>ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先使能外设IO PORTB时钟 </span>  GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_10<span class="token operator">|</span>GPIO_Pin_11<span class="token punctuation">;</span>  <span class="token comment">//端口配置</span>  GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_Out_PP<span class="token punctuation">;</span>   <span class="token comment">//推挽输出</span>  GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>  <span class="token comment">//IO口速度为50MHz</span>  <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//根据设定参数初始化GPIO </span>  <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span>GPIO_Pin_10<span class="token operator">|</span>GPIO_Pin_11<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//PB10,PB11 输出高</span> <span class="token punctuation">}</span><span class="token comment">/**********************************************函数名称：MPU_IIC_Start函数功能：MPU IIC发送起始信号函数参数：无函数返回值：无**********************************************/</span><span class="token keyword">void</span> <span class="token function">MPU_IIC_Start</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">MPU_SDA_OUT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//SDA线 输出</span>MPU_IIC_SDA<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    MPU_IIC_SCL<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token function">MPU_IIC_Delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> MPU_IIC_SDA<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">//START:当SCL线处于高电平时,SDA线突然从高变低,发送起始信号</span><span class="token function">MPU_IIC_Delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MPU_IIC_SCL<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//钳住I2C总线，准备发送或接收数据 </span><span class="token punctuation">}</span><span class="token comment">/**********************************************函数名称：MPU_IIC_Stop函数功能：MPU IIC发送停止信号函数参数：无函数返回值：无**********************************************/</span><span class="token keyword">void</span> <span class="token function">MPU_IIC_Stop</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">MPU_SDA_OUT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//SDA线输出</span>MPU_IIC_SCL<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>MPU_IIC_SDA<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//STOP:当SCL线处于高电平时,SDA线突然从低变高,发送停止信号</span> <span class="token function">MPU_IIC_Delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MPU_IIC_SCL<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> MPU_IIC_SDA<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//发送I2C总线结束信号</span><span class="token function">MPU_IIC_Delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token comment">/**********************************************函数名称：MPU_IIC_Wait_Ack函数功能：MPU IIC等待信号到来函数参数：无函数返回值：1:接收应答信号成功  0:接收应答信号失败**********************************************/</span>u8 <span class="token function">MPU_IIC_Wait_Ack</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>u8 ucErrTime<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token function">MPU_SDA_IN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//SDA设置为输入  </span>MPU_IIC_SDA<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token function">MPU_IIC_Delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MPU_IIC_SCL<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token function">MPU_IIC_Delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>MPU_READ_SDA<span class="token punctuation">)</span><span class="token punctuation">{</span>ucErrTime<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>ucErrTime<span class="token operator">&gt;</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">MPU_IIC_Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>MPU_IIC_SCL<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//时钟输出0</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment">/**********************************************函数名称：MPU_IIC_Ack函数功能：MPU IIC产生应答信号函数参数：无函数返回值：无**********************************************/</span><span class="token keyword">void</span> <span class="token function">MPU_IIC_Ack</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>MPU_IIC_SCL<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token function">MPU_SDA_OUT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MPU_IIC_SDA<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token function">MPU_IIC_Delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MPU_IIC_SCL<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token function">MPU_IIC_Delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MPU_IIC_SCL<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/**********************************************函数名称：MPU_IIC_NAck函数功能：MPU IIC不产生应答信号函数参数：无函数返回值：无**********************************************/</span>   <span class="token keyword">void</span> <span class="token function">MPU_IIC_NAck</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>MPU_IIC_SCL<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token function">MPU_SDA_OUT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MPU_IIC_SDA<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token function">MPU_IIC_Delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MPU_IIC_SCL<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token function">MPU_IIC_Delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MPU_IIC_SCL<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/**********************************************函数名称：MPU_IIC_Send_Byte函数功能：MPU IIC发送一个字节函数参数：txd：要发送的数据函数返回值：无注意：IIC发送字节是一个一个位发送的，发送一个字节需要发送八次**********************************************/</span><span class="token keyword">void</span> <span class="token function">MPU_IIC_Send_Byte</span><span class="token punctuation">(</span>u8 txd<span class="token punctuation">)</span><span class="token punctuation">{</span>                            u8 t<span class="token punctuation">;</span>   <span class="token function">MPU_SDA_OUT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         MPU_IIC_SCL<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//拉低时钟开始数据传输</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>t<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>t<span class="token operator">&lt;</span><span class="token number">8</span><span class="token punctuation">;</span>t<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>                      MPU_IIC_SDA<span class="token operator">=</span><span class="token punctuation">(</span>txd<span class="token operator">&amp;</span><span class="token number">0x80</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token number">7</span><span class="token punctuation">;</span>        txd<span class="token operator">&lt;&lt;=</span><span class="token number">1</span><span class="token punctuation">;</span>       MPU_IIC_SCL<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">MPU_IIC_Delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     MPU_IIC_SCL<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">MPU_IIC_Delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span>     <span class="token comment">/**********************************************函数名称：MPU_IIC_Read_Byte函数功能：MPU IIC读取一个字节函数参数：ack: 1,发送ACK   0,发送NACK 函数返回值：接收到的数据注意：IIC读取字节是一个一个位读取的，读取一个字节需要读取八次**********************************************/</span> u8 <span class="token function">MPU_IIC_Read_Byte</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> ack<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> i<span class="token punctuation">,</span>receive<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">MPU_SDA_IN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">//SDA设置为输入</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">8</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>        MPU_IIC_SCL<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">MPU_IIC_Delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MPU_IIC_SCL<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        receive<span class="token operator">&lt;&lt;=</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>MPU_READ_SDA<span class="token punctuation">)</span>receive<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token comment">//如果读到了数据</span><span class="token function">MPU_IIC_Delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ack<span class="token punctuation">)</span>        <span class="token function">MPU_IIC_NAck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//发送nACK</span>    <span class="token keyword">else</span>        <span class="token function">MPU_IIC_Ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//发送ACK   </span>    <span class="token keyword">return</span> receive<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有一些函数就不做过多赘述了，上面的代码备注已经做好了，认真吃肯定是会吃透的。多下点功夫肯定可以看懂。</p><h1 id="6-学习补充"><a href="#6-学习补充" class="headerlink" title="6.学习补充"></a>6.学习补充</h1><p><strong>补充1：FIFO</strong><br><strong>FIFO</strong>( First Input First Output)简单说就是指先进先出。由于微电子技术的飞速发展，新一代FIFO芯片容量越来越大，体积越来越小，价格越来越便宜。作为一种新型大规模集成电路，FIFO芯片以其灵活、方便、高效的特性，逐渐在高速数据采集、高速数据处理、高速数据传输以及多机处理系统中得到越来越广泛的应用。在系统设计中，以增加数据传输率、处理大量数据流、匹配具有不同传输率的系统为目的而广泛使用FIFO存储器，从而提高了系统性能。FIFO存储器是一个<strong>先入先出的双口缓冲器</strong>，即第一个进入其内的数据第一个被移出，其中一个是存储器的输入口，另一个口是存储器的输出口。对于单片FIFO来说，主要有两种结构：触发导向结构和零导向传输结构。触发导向传输结构的FIFO是由寄存器阵列构成的，零导向传输结构的FIFO是由具有读和写地址指针的双口RAM构成。详见这篇博客：<a href="https://blog.csdn.net/qq_26652069/article/details/90765269">FIFO工作原理</a><br><strong>补充2：关于PA15使用问题</strong><br>在使用PA15作为普通IO口的时候，需要禁用JTAG才可以，代码如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_AFIO<span class="token punctuation">,</span>ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使能AFIO时钟</span><span class="token function">GPIO_PinRemapConfig</span><span class="token punctuation">(</span>GPIO_Remap_SWJ_JTAGDisable<span class="token punctuation">,</span>ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//禁止JTAG,从而PA15可以做普通IO使用,否则PA15不能做普通IO!!!</span><span class="token number">12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>这是个大坑</strong><br><strong>补充3：关于MPU6050参考点</strong><br>当代码烧入后，MPU的参考点是什么呢？参考点其实就是MPU6050初始化之后一开始的位置，没有一个强制的规定哪一个方向就是基准点，<strong>初始化之后的初始位置就是(0，0，0)点</strong>。<br><strong>补充4：想到了再写吧</strong></p><h1 id="7-效果展示-可以先来看这个"><a href="#7-效果展示-可以先来看这个" class="headerlink" title="7.效果展示(可以先来看这个)"></a>7.效果展示(可以先来看这个)</h1><p><img src="https://img-blog.csdnimg.cn/20210527174024629.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpaGFvdGlhbjExMQ==,size_16,color_FFFFFF,t_70#pic_center"><br>PITCH(俯仰角)、ROLL(翻滚角)、YAW(偏航角)，单位均为 度。TEMP为当前温度，单位为摄氏度。</p><h1 id="8-参考链接"><a href="#8-参考链接" class="headerlink" title="8.参考链接"></a>8.参考链接</h1><p>[1]<a href="https://baike.baidu.com/item/%E9%99%80%E8%9E%BA%E4%BB%AA/84317?fr=aladdin">百度百科 陀螺仪</a><br>[2]<a href="http://www.openedv.com/docs/index.html">正点原子资料下载中心</a><br>[3]<a href="https://baike.baidu.com/item/FIFO%E5%AD%98%E5%82%A8%E5%99%A8/4530258?fr=aladdin">百度百科 FIFO储存器</a><br>[4]<a href="https://www.jianshu.com/p/1e38ad3d4bfb">姿态角Pitch、Roll、Yaw角介绍</a></p><h1 id="9-完整版代码链接"><a href="#9-完整版代码链接" class="headerlink" title="9.完整版代码链接"></a>9.完整版代码链接</h1><p><a href="https://download.csdn.net/download/lihaotian111/19131254?spm=1001.2014.3001.5501">MPU6050模块通过OLED显示姿态角源码</a></p>]]></content>
      
      
      <categories>
          
          <category> 电子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在openmv中画图</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      
        <content type="html"><![CDATA[<h4 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h4><ul><li>image.draw_line(line_tuple, color=White) 在图像中画一条直线。<ul><li>line_tuple的格式是(x0, y0, x1, y1)，意思是(x0, y0)到(x1, y1)的直线。</li><li>颜色可以是灰度值(0-255)，或者是彩色值(r, g, b)的tupple。默认是白色</li></ul></li></ul><h4 id="画框"><a href="#画框" class="headerlink" title="画框"></a>画框</h4><ul><li>image.draw_rectangle(rect_tuple, color=White) 在图像中画一个矩形框。<ul><li>rect_tuple 的格式是 (x, y, w, h)。</li></ul></li></ul><h4 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h4><ul><li>image.draw_circle(x, y, radius, color=White) 在图像中画一个圆。<ul><li>x,y是圆心坐标</li><li>radius是圆的半径</li></ul></li></ul><h4 id="画十字"><a href="#画十字" class="headerlink" title="画十字"></a>画十字</h4><ul><li>image.draw_cross(x, y, size=5, color=White) 在图像中画一个十字<ul><li>x,y是坐标</li><li>size是两侧的尺寸</li></ul></li></ul><h4 id="写字"><a href="#写字" class="headerlink" title="写字"></a>写字</h4><ul><li>image.draw_string(x, y, text, color=White) 在图像中写字 8x10的像素<ul><li>x,y是坐标。使用\n, \r, and \r\n会使光标移动到下一行。</li><li>text是要写的字符串。</li></ul></li></ul><h4 id="圆十字瞄准镜例程（qvga类型摄像头）"><a href="#圆十字瞄准镜例程（qvga类型摄像头）" class="headerlink" title="圆十字瞄准镜例程（qvga类型摄像头）"></a>圆十字瞄准镜例程（qvga类型摄像头）</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> sensor<span class="token punctuation">,</span> image<span class="token punctuation">,</span> timesensor<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 初始化摄像头</span>sensor<span class="token punctuation">.</span>set_pixformat<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>RGB565<span class="token punctuation">)</span> <span class="token comment"># 格式为 RGB565.</span>sensor<span class="token punctuation">.</span>set_framesize<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>QVGA<span class="token punctuation">)</span>sensor<span class="token punctuation">.</span>skip_frames<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment"># 跳过10帧，使新设置生效</span>sensor<span class="token punctuation">.</span>set_hmirror<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>sensor<span class="token punctuation">.</span>set_vflip<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    img <span class="token operator">=</span> sensor<span class="token punctuation">.</span>snapshot<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment"># Take a picture and return the image.</span>    img<span class="token punctuation">.</span>draw_line<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">155</span><span class="token punctuation">,</span> <span class="token number">115</span><span class="token punctuation">,</span> <span class="token number">160</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">155</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    img<span class="token punctuation">.</span>draw_line<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">160</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">,</span> <span class="token number">165</span><span class="token punctuation">,</span> <span class="token number">115</span><span class="token punctuation">)</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    img<span class="token punctuation">.</span>draw_rectangle<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">145</span><span class="token punctuation">,</span> <span class="token number">105</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    img<span class="token punctuation">.</span>draw_circle<span class="token punctuation">(</span><span class="token number">160</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span>    img<span class="token punctuation">.</span>draw_cross<span class="token punctuation">(</span><span class="token number">160</span><span class="token punctuation">,</span><span class="token number">120</span><span class="token punctuation">,</span>size<span class="token operator">=</span><span class="token number">15</span><span class="token punctuation">)</span>    img<span class="token punctuation">.</span>draw_string<span class="token punctuation">(</span><span class="token number">140</span><span class="token punctuation">,</span><span class="token number">135</span><span class="token punctuation">,</span> <span class="token string">"Target"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果（我学习用的摄像头垃圾，见谅）</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210611112253.png" alt="1"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#引入感光元件的模块</span><span class="token keyword">import</span> sensor<span class="token punctuation">,</span> image<span class="token punctuation">,</span> timesensor<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>                      <span class="token comment"># 初始化元器件</span>sensor<span class="token punctuation">.</span>set_pixformat<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>RGB565<span class="token punctuation">)</span> <span class="token comment"># 设置为彩色</span><span class="token comment">#设置翻转</span><span class="token comment">#水平方向翻转</span>sensor<span class="token punctuation">.</span>set_hmirror<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>sensor<span class="token punctuation">.</span>set_vflip<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token comment">#垂直方向翻转</span><span class="token comment">#设置图像大小</span>sensor<span class="token punctuation">.</span>set_framesize<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>QVGA<span class="token punctuation">)</span>sensor<span class="token punctuation">.</span>skip_frames<span class="token punctuation">(</span>time <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">)</span>     <span class="token comment"># #跳过n张照片，在更改设置后，跳过一些帧，等待感光元件变稳定。</span>clock <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment"># Create a clock object to track the FPS.</span>sensor<span class="token punctuation">.</span>set_auto_gain<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span> <span class="token comment">#自动增益开启（True）或者关闭（False）。在使用颜色追踪时，需要关闭自动增益。</span>sensor<span class="token punctuation">.</span>set_auto_whitebal<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span> <span class="token comment">#自动白平衡开启（True）或者关闭（False）。在使用颜色追踪时，需要关闭自动白平衡。</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    img <span class="token operator">=</span> sensor<span class="token punctuation">.</span>snapshot<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment"># Take a picture and return the image.</span>    img<span class="token punctuation">.</span>draw_line<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">145</span><span class="token punctuation">,</span> <span class="token number">105</span><span class="token punctuation">,</span> <span class="token number">160</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    img<span class="token punctuation">.</span>draw_line<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">175</span><span class="token punctuation">,</span> <span class="token number">105</span><span class="token punctuation">,</span> <span class="token number">160</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    img<span class="token punctuation">.</span>draw_rectangle<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">145</span><span class="token punctuation">,</span> <span class="token number">105</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    img<span class="token punctuation">.</span>draw_circle<span class="token punctuation">(</span><span class="token number">160</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span>    img<span class="token punctuation">.</span>draw_cross<span class="token punctuation">(</span><span class="token number">160</span><span class="token punctuation">,</span><span class="token number">120</span><span class="token punctuation">,</span>size<span class="token operator">=</span><span class="token number">15</span><span class="token punctuation">)</span>    img<span class="token punctuation">.</span>draw_string<span class="token punctuation">(</span><span class="token number">140</span><span class="token punctuation">,</span><span class="token number">140</span><span class="token punctuation">,</span> <span class="token string">"Target！"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有这种的，需要其他样式的话，根据代码和注释魔改即可。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210611112310.png" alt="2"></p>]]></content>
      
      
      <categories>
          
          <category> openmv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openmv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bug_arduino_固件</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      
        <content type="html"><![CDATA[<center> bug的来源十分简单，github上的那个grbl例程包里面有个小问题。那个grbl的包只要刷进去开发板，你的开发板就不能再写入其他程序了。是不是很诡异  </center><span id="more"></span><p><img src="https://i.loli.net/2021/04/18/3mMUzEtJoV6pyR4.png"></p><p><img src="https://i.loli.net/2021/04/18/cot1SMRln6zvNBE.png"></p><p>包括arduino ide本身也不能再次刷进去程序了，很是诡异。一些老哥说是bootloader给刷掉了，改天刷一个看看是否能还原。</p><p>就目前的项目来看，只能再买一个开发板了。日了</p><p><img src="https://i.loli.net/2021/04/18/YC1wpWbiaUEeGRq.png"></p><p>再也不刷这个包了。。。。。。</p>]]></content>
      
      
      <categories>
          
          <category> bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些想法</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      
        <content type="html"><![CDATA[<center>  都说人闲着的话能闲出来毛病，我为啥一闲下来就有一些奇怪的想法。。。。 </center><span id="more"></span><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">背景音乐:【呐呐呐——镜音；初音】<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><audio id="audio" controls="" preload="none"><source id="mp3" src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/music/%E3%80%90%E9%8F%A1%E9%9F%B3%E3%83%AA%E3%83%B3%E3%83%BB%E5%88%9D%E9%9F%B3%E3%83%9F%E3%82%AF%E3%80%91%E5%91%90%E5%91%90%E5%91%90%E3%80%90%E3%83%94%E3%83%8E%E3%82%AD%E3%82%AA%E3%83%94%E3%83%BC%E3%80%91%20.mp3"></audio><h4 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h4><h4 id="1-迷你打印机"><a href="#1-迷你打印机" class="headerlink" title="1.迷你打印机"></a>1.迷你打印机</h4><p>虽然这个玩意早就有了，但是我还是想要搞一个。</p><p>原因：</p><p>之前需要写很多报告之类的东西，动不动就成千上万字，很难受。但是还tm不让打印，你说抄那玩意干啥?你又不看，我们抄下来也不过脑子，实验也是水一下，图个啥吧。起初我是想搞个之前网上很火的那种写字机来着（并且我也搞了）。</p><img src="https://i.loli.net/2021/04/17/4cvlsnkxWe8iLFJ.jpg" alt="雕刻机" style="zoom:67%;"><p>这个是半成品，再加个小舵机写字模块就行了，问题不大。但是这个玩意有个问题，就是写字太慢了，毕竟拿笔写哪里有直接印的快。</p><p>于是乎，做个小打印机的想法就出来了。就是那种扫描一下识别字体，然后修正成自己的字体，再打印出来的那种小玩意。但是仔细想想，这种东西好像也不适合偷懒写报告。<strong>BUT</strong>他是不是很适合做笔记呢？？？</p><p><strong>是不是？</strong></p><p>有时候，我们做笔记其实就是把课本上的照抄一下，是不是有点浪费时间，并且有的图表我们也是画不了太规范.使用工具进行绘制的话又太浪费时间。直接打印的话，还要编辑文档（word，cad啥的）然后只能打印到打印纸上，想弄到笔记上还要进行裁剪粘贴，时间都浪费了。如果有这样一个小玩意，扫描一下原文本就可以直接打印在我们的笔记上，岂不美哉。省了时间还不用裁剪之类的操作就可以把很多东西放到我们的笔记上（还是纸质的）。<strong>COOL!</strong></p><p>这个玩意太极客了，就是目前做不出来。。。。。</p><h4 id="2-还没想好名字"><a href="#2-还没想好名字" class="headerlink" title="2.还没想好名字"></a>2.还没想好名字</h4><p>大概就是一种特殊的传输结构可以快速还原一些地形和形状，有点像我们玩的那种橡皮泥插上牙签的一个玩意。具体有啥用，还没想好，以后再加。</p><hr><p>下面的是一些别的大佬的玩具（真厉害），改天没事了复刻一个！</p><p><img src="https://i.loli.net/2021/04/17/VWwmqOoiHckdgvy.jpg" alt="2" style="zoom:67%;"><img src="https://i.loli.net/2021/04/17/lo8Xai92z1CjQdL.jpg" alt="3" style="zoom:67%;"></p><p>发现材料不够以后再复刻。</p>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bug_arduino_timeout</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      
        <content type="html"><![CDATA[<center>  前面几天搞了个激光雕刻机玩玩，但是玩了一半的时候控制板gg了，所以我又刷了下固件，然后。。。。。 </center><p><img src="https://i.loli.net/2021/04/16/iD3tlZvuJBwzaex.png"></p><span id="more"></span><p>Debug :</p><p>排除了bootload的问题</p><p>排除了芯片型号的问题</p><p>排除了驱动的问题</p><p>排除了接线的问题</p><p>排除了软件（上位机）问题</p><p>未排除下位机是否存在问题</p><p>未排除开发板是否短路</p><p>未排除开发板是否有故障</p><p>没有找到解决方案，打算换个控制系统试一下。</p><hr><p>后记：板子是盗版的，艹了，芯片内存溢出后gg了</p>]]></content>
      
      
      <categories>
          
          <category> bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流程图</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      
        <content type="html"><![CDATA[<center> 程序框图也叫做流程图，它直观形象,易于理解，是描述算法的常用方式。美国国家标准化协会（ANSI）规定了一些常用的程序框图符号（如下图所示），已经成为世界各国程序工作者普遍采用的标准。  </center><img src="https://img-blog.csdnimg.cn/20190401090908105.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjc1MzEz,size_16,color_FFFFFF,t_70" alt="1.jpg" style="zoom: 67%;"><span id="more"></span><p>从网络上找了个例子如下：</p><p><img src="https://img-blog.csdnimg.cn/20190401091228716.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjc1MzEz,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20190401090941605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjc1MzEz,size_16,color_FFFFFF,t_70" alt="img"></p><p>是不是和上一篇文章的伪代码有点像呢？其实这两个可以结合使用的，并且还经常这么干。</p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>不论什么程序设计语言，程序设计都有3种基本结构：顺序结构、选择结构和循环结构。三种基本结构的特点： 一个入口，一个出口，不出现死循环和死语句。</p><img src="https://img-blog.csdn.net/20180923195231944" alt="img" style="zoom:50%;"><img src="https://img-blog.csdn.net/20180923195402731" alt="img" style="zoom:50%;"><img src="https://img-blog.csdnimg.cn/20181227164842271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDMwMTExNA==,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 67%;"><h3 id="实际应用类型"><a href="#实际应用类型" class="headerlink" title="实际应用类型"></a>实际应用类型</h3><p>一般我们理工狗使用的较多的是<u>系统流程图与程序流程图</u>。此外还有<u>业务路程图、任务流程图、页面流程图</u>。多了解几个流程图更有助于我们理解这个新的事物，故将其列举于此。</p><p>一般说来做系统高层设计时，首先会考虑系统的整体结构，把<strong>系统</strong>会分成多个<strong>子系统</strong>，每个<strong>子系统</strong>又分成多个<strong>程序模块</strong>。系统流程图用图形化的符号来记录整个系统和系统各模块的结构，描述了系统各子系统、相关文件和数据之间的关系，记录了整个系统的体系结构。系统流程图主要应用在系统架构阶段，是系统分析员或系统设计师对将要构建系统的一种描述，这种描述以简单图形化的方式给出了系统的整体结构，涉及到系统将要使用的各种部件，如<strong>子系统、数据库、磁盘、文件、用户的输入与输出</strong>等。而每个模块中，单个功能的实现则可用程序流程图来描述。</p><p>下面展示几个例子：</p><p><strong>程序流程图</strong>：</p><img src="https://img-blog.csdnimg.cn/20191216113341635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JpcmRfdHA=,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 80%;"> <p><strong>系统流程图</strong>：</p><img src="https://img-blog.csdnimg.cn/20191216113443426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JpcmRfdHA=,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 80%;"><p>同为流程图，下面这三个商务类的了解一下即可，因为对c语言学习帮助不大。</p><p><strong>业务流程图</strong><br>业务流程图就是描述那些个体在什么条件下做了什么事情，他们之间有何关联。主要分三个方面：</p><ul><li>涉及到哪些主体？</li><li>每个主体都有哪些任务？</li><li>各个主体之间怎么联系的？</li></ul><p>一般涉及到多个主体，每个主体之间有联系，比如p2p平台。下图为p2p的业务流程图、涉及到借款人、平台、投资人、第三方支付四个主体，以及每个主题需要完成的任务、任务之间的联系和先后顺序。<br><img src="https://img-blog.csdnimg.cn/20190510152051210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODExNDg5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>任务流程图</strong></p><p>泳道图一般是从战略上分析整个业务流程，让你对公司所做的业务有个大概的了解，而任务流程图就是在你的产品操作上，用户通过什么样的操作来完成它的目标，比如你去银行ATM机器上取钱，你是如何一步步操作把钱取出来的，这里以p2p理财产品购买为例，来说明购买的任务流程图。</p><img src="https://img-blog.csdnimg.cn/20190510152125838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODExNDg5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">画流程图的时候注意主要流程和异常流程，在这个例子中，主要流程就是购买流程、异常流程就是没有设置交易密码、用户忘记交易密码、以及超过重试次数这些流程，画流程图的时候先画主要的流程，然后再把异常额流程考虑上，查漏补缺，保证不遗漏，产品的逻辑漏洞多半是由于异常情况没有考虑清楚，画流程图可以有效的帮助你梳理逻辑。<p><strong>页面流程图</strong></p><p>如果说业务流程图帮助你梳理战略，任务流程图帮助你梳理用户操作行为（主要给程序员看）、页面跳转流程在帮助你梳理各个页面之间的跳转关系（主要给UI和前端程序员看）这是一个逐步从整体到局部，从后端到前端的过程。</p><p>所有的产品都是由页面组成的，不论是APP、PC、H5都是由一个个页面组成的，页面流程图描述完成一个任务需要经过哪些步骤，你在画图的时候只需要清晰的表现出用户点击页面的什么地方，然后跳转到那个页面。主要由页面、行动点、连接线组成，下面以用户购买理财产品举例。</p><img src="https://img-blog.csdnimg.cn/20190510152236906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODExNDg5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">页面流程一般只考虑正常的操作流程就行，对于异常的操作流程在正常流程的旁边画出，例如：上面的正常页面跳转是用户购买这个流程，异常页面跳转流程是在购买界面金额不足的时候点击去充值流程，这个在正常流程的旁边标示出来就好。<p>对这三种流程图感兴趣的话，来源：<a href="https://blog.csdn.net/qq_32811489/article/details/90067054?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161266580216780264089304%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161266580216780264089304&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-90067054.first_rank_v2_pc_rank_v29_10&amp;utm_term=%E6%B5%81%E7%A8%8B%E5%9B%BE&amp;spm=1018.2226.3001.4187">流程图介绍以及工具推荐</a></p><h3 id="文章来源："><a href="#文章来源：" class="headerlink" title="文章来源："></a>文章来源：</h3><p><a href="https://blog.csdn.net/bird_tp/article/details/103559761?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E6%B5%81%E7%A8%8B%E5%9B%BE&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-8-103559761.first_rank_v2_pc_rank_v29_10&amp;spm=1018.2226.3001.4187">流程图学习</a></p><p><a href="https://blog.csdn.net/qq_42675313/article/details/88941058?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161266580216780264089304%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161266580216780264089304&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-6-88941058.first_rank_v2_pc_rank_v29_10&amp;utm_term=%E6%B5%81%E7%A8%8B%E5%9B%BE&amp;spm=1018.2226.3001.4187">一个简单的画程序框图例子</a></p><p>另外如果需要绘制流程图，下面为快速链接</p><p><a href="https://blog.csdn.net/langhonglin/article/details/81091727?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161266580216780264042445%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=161266580216780264042445&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-10-81091727.first_rank_v2_pc_rank_v29_10&amp;utm_term=%E6%B5%81%E7%A8%8B%E5%9B%BE&amp;spm=1018.2226.3001.4187">画流程图的软件教程</a></p>]]></content>
      
      
      <categories>
          
          <category> c语言学习历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言初步学习 </tag>
            
            <tag> 流程图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言初步学习——伪代码(1)</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      
        <content type="html"><![CDATA[<p>伪代码（Pseudocode）是一种非正式的，类似于英语结构的，用于描述模块结构图的语言，并且英语国家使用的较多。人们在用不同的编程语言实现同一个算法时意识到，他们的实现（注意：这里是实现，不是功能）很不同。尤其是对于那些熟练于不同编程语言的程序员要理解一个（用其他编程语言编写的程序的）功能时可能很难，因为程序语言的形式限制了程序员对程序关键部分的理解。这样伪代码就应运而生了。伪代码提供了更多的设计信息，每一个模块的描述都必须与设计结构图一起出现。<br>使用伪代码的目的是使被描述的算法可以容易地以任何一种编程语言（Pascal，C，Java等）实现。因此，伪代码必须结构清晰、代码简单、可读性好，并且类似自然语言。 介于自然语言与编程语言之间。以编程语言的书写形式指明算法职能。使用伪代码， 不用拘泥于具体实现。相比程序语言（例如Java, C++,C, Dephi 等等）它更类似自然语言。它是半角式化、不标准的语言。可以将整个算法运行过程的结构用接近自然语言的形式（可以使用任何一种你熟悉的文字，关键是把程序的意思表达出来）描述出来。这个在数据结构讲算法等部分体现的较多。</p><p>并且，学习代码类相关专业的同学，在<a href="https://blog.csdn.net/weixin_41275726/article/details/102796822?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161228068816780266227075%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&amp;request_id=161228068816780266227075&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-102796822.first_rank_v2_pc_rank_v29_10&amp;utm_term=%25E4%25BC%25AA%25E4%25BB%25A3%25E7%25A0%2581"><strong>论文</strong></a>上也要使用一些相关的伪代码，所以<strong>掌握</strong>伪代码的写法也是很重要的一个环节 。</p><span id="more"></span><h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><p>　　例如，类Pascal语言的伪代码的语法规则是： 在伪代码中，每一条指令占一行（else if，例外）。指令后不跟任何符号（Pascal和C中语句要以分号结尾）。书写上的“缩进”表示程序中的分支程序结构。这种缩进风格也适用于if-then-else语句。用缩进取代传统Pascal中的begin和end语句来表示程序的块结构可以大大提高代码的清晰性；同一模块的语句有相同的缩进量，次一级模块的语句相对与其父级模块的语句缩进。</p><p>  算法的伪代码语言在某些方面可能显得不太正规，但是给我们描述算法提供了很多方便，并且可以使我们忽略算法实现中很多麻烦的细节。通常每个算法开始时都要描述它的输入和输出，而且算法中的每一行都给编上号码，在解释算法的过程中会经常使用算法步骤中的行号来指代算法的步骤。算法的伪代码描述形式上并不是非常严格，其主要特性和通常的规定如下：<br>    1) 算法中出现的数组、变量可以是以下类型：整数、实数、字符、位串或指针。通常这些类型可以从算法的上下文来看是清楚的，并不需要额外加以说明。<br>    2) 在算法中的某些指令或子任务可以用文字来叙述，例如，”设x是A中的最大项”，这里A是一个数组；或者”将x插入L中”，这里L是一个链表。这样做的目的是为了避免因那些与主要问题无关的细节使算法本身杂乱无章。<br>    3) 算术表达式可以使用通常的算术运算符（+，-，<em>，/，以及表示幂的^）。逻辑表达式可以使用关系运算符=,≠,&lt;,&gt;,≤和≥，以及逻辑运算符与(and),或（or），非（not）。<br>    4) 赋值语句是如下形式的语句：a&lt;-b 。<br>这里a是变量、数组项，b是算术表达式、逻辑表达式或指针表达式。语句的含义是将b的值赋给a。<br>    5) 若a和b都是变量、数组项，那么记号a&lt;-&gt;b 表示a和b的内容进行交换。<br>    6) goto语句具有形式<br>                    goto label（goto标号）<br>它将导致转向具有指定标号的语句。<br>    7) 条件语句有以下两种形式：<br>                      if c then s或者<br>                        if c then s<br>                         else s′<br>这里c是逻辑表达式，s和s′是单一的语句或者是被括在do和end之间的语句串。对于上述两种形式，假若c为真，则s被执行一次。假若c为假，则在第一种形式中，if语句的执行就完成了，而在第二种形式中，执行s′。在所有的情况下，控制就进行到了下一个语句，除非在s或s′中的goto语句使控制转向到其它地方。<br>     8) 有两种循环指令：while和for。<br>     while语句的形式是<br>                       while c do<br>                          s<br>                         end<br>这里c是逻辑表达式，而s是由一个或更多个语句组成的语句串。当c为真时，执行s。在每一次执行s之前，c都被检查一下；假若c为假，控制就进行到紧跟在while语句后面的语句。注意，当控制第一次达到while语句时，假若c为假，则s一次也不执行。<br>    for语句的形式是<br>                   for var init to limit by incr do<br>                            s<br>                           end<br>这里var是变量，init、limit和incr都是算术表达式，而s是由一个或多个语句组成的语句串。初始时，var被赋予init的值。假若incr≥0，则只要var≤limit，就执行s并且将incr加到var上。（假若incr&lt;0，则只要var≥limit，就执行s并且将incr加到var上）。incr的符号不能由s来该改变。<br>   9) exit语句可以在通常的结束条件满足之前，被用来结束while循环或者for循环的执行。exit导致转向到紧接在包含exit的（最内层）while或者for循环后面的一个语句。<br>   10) return用来指出一个算法执行的终点；如果算法在最后一条指令之后结束，它通常是被省略的；它被用得最多的场合是检测到不合需要的条件时。return的后面可以紧接被括在引号的信息。<br>   11) 算法中的注释被括在/</em> */之中。诸如read和output之类的各种输入或者输出也在需要时被用到。</p><p><strong>伪代码实例</strong></p><p>　　伪代码只是像流程图一样用在程序设计的初期，帮助写出程序流程。简单的程序一般都不用写流程、写思路，但是复杂的代码，最好还是把流程写下来，总体上去考虑整个功能如何实现。写完以后不仅可以用来作为以后测试,维护的基础，还可用来与他人交流。但是，如果把全部的东西写下来必定可能会让费很多时间，那么这个时候可以采用伪代码方式。比如：</p><pre class="line-numbers language-伪代码" data-language="伪代码"><code class="language-伪代码">IF 九点以前 THENdo 私人事务；ELSE 9点到18点 THEN工作；ELSE下班;END IF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　这样不但可以达到文档的效果,同时可以节约时间. 更重要的是,使结构比较清晰,表达方式更加直观.</p><p>　　下面介绍一种类Pascal语言的伪代码的语法规则。</p><p>　　在伪代码中，每一条指令占一行(else if 例外，)，指令后不跟任何符号（Pascal和C中语句要以分号结尾）；</p><p>　　书写上的“缩进”表示程序中的分支程序结构。这种缩进风格也适用于if-then-else语句。用缩进取代传统Pascal中的begin和end语句来表示程序的块结构可以大大提高代码的清晰性；同一模块的语句有相同的缩进量，次一级模块的语句相对与其父级模块的语句缩进；　</p><p>　　在伪代码中，通常用连续的数字或字母来标示同一即模块中的连续语句，有时也可省略标号。</p><p>　　符号△后的内容表示注释；</p><p>　　在伪代码中，变量名和保留字不区分大小写，这一点和Pascal相同，与C或C++不同；</p><p>　　在伪代码中，变量不需声明，但变量局部于特定过程，不能不加显示的说明就使用全局变量；</p><p>　　赋值语句用符号←表示，x←exp表示将exp的值赋给x，其中x是一个变量，exp是一个与x同类型的变量或表达式（该表达式的结果与x同类型）；多重赋值i←j←e是将表达式e的值赋给变量i和j，这种表示与j←e和i←e等价。</p><p>　　例如：</p><pre><code>x←yx←20*(y+1)x←y←30</code></pre><p>　　以上语句用C分别表示为：</p><pre><code>x = y;x = 20*(y+1);x = y = 30;</code></pre><p>　　选择语句用if-then-else来表示，并且这种if-then-else可以嵌套，与Pascal中的if-then-else没有什么区别。</p><p>　　例如:</p><pre><code>if (Condition1)then [ Block 1 ]else if (Condition2)then [ Block 2 ]else [ Block 3 ]</code></pre><p>　　循环语句有三种：while循环、repeat-until循环和for循环，其语法均与Pascal类似，只是用缩进代替begin - end；</p><p>　　例如：</p><ul><li>x ← 0</li><li>y ← 0</li><li>z ← 0</li><li>while x &lt; N</li><li>do x ← x + 1</li><li>y ← x + y</li><li>for t ← 0 to 10</li><li>do z ← ( z + x * y ) / 100</li><li>repeat</li><li>y ← y + 1</li><li>z ← z - y</li><li>until z &lt; 0</li><li>z ← x * y</li><li>y ← y / 2</li></ul><p>上述语句用C或C++来描述是：</p><pre><code>x = y = z = 0;while( z &lt; N ){x ++;y += x;for( t = 0; t &lt; 10; t++ ){z = ( z + x * y ) / 100;do {y ++;z -= y;} while( z &gt;= 0 );}z = x * y;}y /= 2;</code></pre><p>　　数组元素的存取有数组名后跟“[下标]”表示。例如A[j]指示数组A的第j个元素。符号“ …”用来指示数组中值的范围。</p><p>　　例如：</p><p>　　A[1…j]表示含元素A[1], A[2], … , A[j]的子数组；</p><p>　　复合数据用对象(Object)来表示，对象由属性(attribute)和域(field)构成。域的存取是由域名后接由方括号括住的对象名表示。</p><p>　　例如：</p><p>　　数组可被看作是一个对象，其属性有length，表示其中元素的个数，则length[A]就表示数组A中的元素的个数。在表示数组元素和对象属性时都要用方括号，一般来说从上下文可以看出其含义。</p><p>　　用于表示一个数组或对象的变量被看作是指向表示数组或对象的数据的一个指针。对于某个对象x的所有域f，赋值y←x就使f[y]=f[x]，更进一步，若有f[x]←3，则不仅有f[x]=3，同时有f[y]=3，换言之，在赋值y←x后，x和y指向同一个对象。</p><p>　　有时，一个指针不指向任何对象，这时我们赋给他nil。</p><p>　　函数和过程语法与Pascal类似。</p><p>　　函数值利用 “return (函数返回值)” 语句来返回，调用方法与Pascal类似；过程用 “call 过程名”语句来调用；</p><p>　　例如：</p><p>　　1. x ← t + 10</p><p>　　2. y ← sin(x)</p><p>　　3. call CalValue(x,y)</p><p>　　参数用按值传递方式传给一个过程：被调用过程接受参数的一份副本，若他对某个参数赋值，则这种变化对发出调用的过程是不可见的。当传递一个对象时，只是拷贝指向该对象的指针，而不拷贝其各个域。 </p><p>部分文章来源：<a href="https://www.cnblogs.com/huipengkankan/archive/2011/07/28/2120416.html">伪代码规范</a></p>]]></content>
      
      
      <categories>
          
          <category> c语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
            <tag> 伪代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AD快捷键</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      
        <content type="html"><![CDATA[<p>1：shift+s 键 切换单层显示<br>2：q   英寸和毫米 尺寸切换<br>3：D+R进入布线规则设置。其中 Clearance 是设置最小安全线间距，覆铜时候间距的。比较常用<br>4：CTRL+鼠标单击某个线，整个线的NET 网络 呈现高亮状态<br>5：小键盘上的 * （星号键）可以在top、bottom layer 切换，达到快速切换上下层。另外 + - 可以把所有显示的层轮流切换。<br>6：CTRL+SHIFT+ T 、B、L、R 可以快速对齐所选中的元件 上 下 左 右。<br>7：M+I 可以把选中所有的元件，翻转过来。这样可以在上下层切换，方便布线，调整印丝层。 很实用的一个操作。<br>8：如上所述，还可以 查看板子底部，就点击  查看  翻转板子 板子就反过来，但是属性还是 一样。只是从板子底部看了。<br>9：器件联合 选中两个器件 然后右击 选择 联合-从选中的器件生成联合 这样可以操作两个位置在一起的器件<br>当要去掉时候 选中器件 右击 联合-从联合打散器件  那么连接在一起的就能够单独操作了。<br>当选中联合的器件，右击选择联合，有个 选择所有的联合 这样一下子选择所有联合的器件。固定的外框就可以联合起来移动操作。<br>10：多根线同时画的时候，每个先画个短的线，按SHIFT 选中所有一起画的线，选好，松开SHIFT. 鼠标移动到线头 白点处，然后拖动，那么所有线就一起拖动。 转弯一次，松开， 在拖，又可以转弯。<br>11: 快捷键 t c 交叉探针 看到寻找 原理图 和 PCB 的元件位置  选下，然后跑到PCB 就能看到原理图那个元件的位置。<br>12: ed 删线<br>13: 捕获焊盘 查看——网格——切换电气网格（shift + E）</p><p>方格与格点的切换:View-Grids-ToggleVisible Grid Kind</p><p>原点：Edit-Origin-Set<br>边界的定义：Keep Out Layer-Utility Tools-Place Line 按TAB可定义线宽<br>选取元件：PCB-PCB Filter-IS Component<br>逐个放置元件：TOOLS-Component Placement-RepositionSelected Components<br>自动布局：ToolS-Component Placement–Arrange Within Room<br>自动布局器：ToolS-Component Placement–Auto Placer<br>元件排列：选中元件右键Align-  或Alignment Tools–</p><p>元件在层之间的快速切换：拖动元件的过程按L键<br>让焊盘放在格点上：选中元件，右键-Component Actions-Move ComponentOrigin To Grid<br>移动元件的远近：”G”键 选择mil<br>刷新屏幕： END<br>改走线模式：shift+空格键<br>（“45°线性” “45°+圆角” “90°”“ 任意角”“90°+圆弧 ”“圆弧”）<br>遇障碍物：右键-Options-Preferences-…<br>推挤： Shift+R<br>布线快捷菜单：“~ ”键<br>线宽设置：“Shift+W”</p><p>过孔修改规则:Design-Rules-HoleSize;<br>板边5mm圆弧:Place-KeepOut-Arc<br>切换英美单位制度：Ctrl+Q </p><p>保护元器件位置：锁定 双击-Lock打钩<br>保护已锁定物体：Tools-Preference-PCB Editer-General-ProtectLocked Objects 打勾；</p><p>显示布线快捷菜单：键盘左上角快捷键“~ ”</p><p>层间切换：”+””-“</p><p>字体（条形码）放置：”A”-Place String；<br>对板的定义：Designers-Board Shape-R/D；<br>尺寸标注：Place Dimension-Place Linear Dimension<br>工具栏恢复原始状态:在工具栏处右键CustomizingPCB Editor-Toolbar-Restore；<br>填充：Place Fill；</p><p>复制粘贴：选中-Edit-Rubber Stamp-单击<br>粘贴特殊形状：选中-Edit-Paste Special<br>选择一组Select：“S键”-Touching Liner线/Rectangle矩形<br>或Shift 一个个选<br>移动Move:”M”<br>整体移动：选中-右键-Unions-Create Union fromselected object/break<br>解脱从联合体<br>弱小信号线包地：选中-“s”select net,Tool-Outline-Selected Objects<br>查找相似物体：右键-Find SimilarObject</p><p>测距离：Report-Measure Distance<br>自动布线:Auto Route:Net/NetClass/Connection/Area/Room</p><p>查看布线层：Shift+F或“*”切换层<br>切断线：Edit-Slice Tracks<br>布完线进行规则检查：Tools-Design Rule Check-Run D_R_C_<br>3D视图：数字键“3”或View-Switch to3D,Shift+右键旋转；</p><p>铺铜：Place-Polyon Pour</p><p>去死铜：<strong>双击铜区，Remove Deader Copper 打勾</strong></p><p>原理图和PCB的双向同步更新：<br>检测PCB与原理图的不同处：Project-Show Differences<br>在原理图里更改后更新到PCB:Design-Update PCB Document in<br>在PCB里更改后更新到原理图:Design-UpdateSchematics in<br>标号Designator显示：PCB FilterISDesignator 然后PCB Inspector Hide<br>重新标注：Tool- Re Annotate</p><p>元器件标号自动排列：选中器件-右键-Align-Position Component Text<br>补泪滴：Tool-Teardrops，焊盘与导线连接更牢固<br>生成生产制造文件：File-Fabrication Outputs<br>生成PDF文件：File-Smart PDF<br>翻板：View-Flip Board</p><p><strong>打开层对话框：****L</strong></p><p>打开选择：S<br>跳转：J<br>英寸和毫米切换：Q<br>翻转元器件：空格<br>改变线宽，孔径：选中导线或过孔,同时按下Tab键<br>选中目标：shift+单击</p><p>PCB换层并自动添加过孔：小键盘上的“*”<br>系统设置：DXP-&gt;preferences<br>其中General–Use localized resources中文<br>其中Backup ：设置备份时间<br>树形图标：home<br>快捷键：右下角help-shortcuts<br>默认布局：View-Desktop layouts–Default<br>窗口缩回的速度：DXP-&gt;preferences-&gt;system-&gt;view–Hidedelay<br>打开不同面板：右下角System等等<br>切换不同窗口：ctrl+tab<br>放大和缩小：ctrl+鼠标中键滚轴<br>修改右下方的边框(title，日期)格式：DeSign-Template-Set Template File Name…A4 </p><p><strong>走线自动延长：</strong> <strong>Drag—ctrl+鼠标拖动</strong></p><p>复制目标：选择目标，按住shift拖动<br>自动添加元件编号：Tools-&gt;Annotate Schematics<br>Preferences–&gt;Schematic–&gt;Graphical Editing Convert Special Strings 转换特殊字符串</p><p>如何全局修改<br>例如：单击电容C1选中，鼠标右键选择Find Similar Objects (Select Matching 选中，二步骤可以跳过</p><p>(1) Part Comment —same Current Footprint —same ,点击OK按钮<br>(2) Select ALL<br>(3) SCH Inspector 窗口 修改 Footprint<br>Tools–&gt;FootPrint Manager</p><p>分层设计</p><p>(1)一种水平设置，N个分图 ，net设置全局(project–&gt;project options–&gt;<a href="http://www.wenkuxiazai.comidentifier/">http://www.wenkuxiazai.comIdentifier</a> Scope..Gloal) 不推荐<br>(2)一种垂直设置</p><p>，一个总图(Sheet Entry),N个分图(PORT) 连接只能Sheet Entry到PORT<br>第二种方法：<br>(1)Place sheet Symbol(方框) 和sheet Entry(放在方框边界内侧)<br>(2)选择sheet Symbol，右键选择”Sheetsymbol actions”–creat sheet from symbol<br>原理图库<br>(1) File–&gt;New–&gt;Library–&gt;sch..<br>(2) 右边下方SCH打开SCH Library</p><p>窗口<br>(3) Place-&gt;RecTangle,注意放在原点<br>(4) Library Components Properties<br>Designator U?<br>Comment max232<br>Symbol Refernece max234<br>(5) 可将一个元件库分为两个Part,例如parta,partb(通过Tools–&gt;new part)<br>特殊用途：选择该元件，按F1打开该元件的pdf文档<br>Library Components Properties–&gt;Parameters for Component –&gt;Add..<br>Name: HelpURL Value: C:\zy\abc.pdf#page=5</p><p>PCB库</p><p>(1) File–&gt;New–&gt;Library–&gt;pcb..<br>(2) 右边下方PCB打开pcb Library 窗口<br><strong>集成库</strong></p><p>(1) File–&gt;New–&gt;Project–&gt;Interger Library<br>(2) 新建sch.lib和pcb.lib, 在sch.lib中选择Tools–&gt;Model Manage….<br>(3) Project–&gt;Compile Integrated Library<br>盲孔（BIINDVIA）：从印制板内仅延展到一个表层的导通孔。<br>埋孔（BURIEDVIA）：未延伸到印制板表面的一种导通孔。</p><p>PCB绘制</p><p>(1) 在PCB中 Design–&gt;ImportChanges From…..<br>(2) S+N 选择相同net的线<br>(3) Design–&gt;Board layers &amp; color–&gt;show/hide polygons hide (将覆铜隐藏) （L快捷键）<br>(4) 查看PCB元件，通过打开PCB窗口，选择Components<br>(5) shift+S 单层打开或关闭<br>(6) 对弱小信号可选择包地处理(Tools–&gt;Outline Selected Object)<br>(7) Tools–&gt;Design Rule Check…<br>(8) File–&gt;Fabrication Outputs–&gt;Gerber Files </p><p><strong>覆铜：</strong></p><p>place–&gt;polygon Pour…<br>\1. Pour Over Same Net Polygons Only 相同net铜箔覆盖<br>\2. Pour Over All Same Net Objects 铜箔覆盖相同net部分（将相同net的导线等等融合了)<br>注意 ：如果要保存为PCB4.0 Binary File(*.pcb), 覆铜要选择网格式，(可将网格Track With和GridSize设置一样，就如同Solid格式了)<br>如何隐藏所有Designator(即u1,r1,r2….)<br>(1) PCB filer–&gt;IsDesignator 选择所有Designator<br>(2) PCB Inspector–&gt;Hide<br>如何将Designator(即u1,r1,r2….)自动放置在元件附件<br>(1) PCB filer–&gt;IsComponent<br>(2) Align–&gt;Position Component Text….<br>将PCB翻转 查看反面方便 view–&gt;FilpBoard<br>PCB查看层数 Design–&gt;Layer Stack Manager<br>“类” Design–&gt;class<br>比如新建一个net class ,把Vc3.3 VC5等加入，然后在rule中选择Net class,这样规则适用范围就是自己定义的类了<br>按键2–2D 按键3–3D</p><p>原理图画线：P+W</p><p>PCB图画线： P+T<br>在原理图里同快速查找元器件：CTRL+F<br>在PCB里面快速查的元件：J+C </p><p> 选择net： ctr+H或S+N<br>去掉全部选中物体：E+E+A<br> 删除两个焊点间的导线：T+U+C</p><p>单层打开或关闭：shift+S </p><p>去掉过滤：shift+C </p><p> 在交互布线的过程中，切换布线形状：Shift+空格键</p><p> 拖动时连线跟着延长：ctrl+鼠标左键拖动</p><p> PCB选择相同net，并高亮：ctrl+鼠标右键</p><p> hide/show层：ctrl+D</p><p><strong>原理图和PCB快速切换：****ctrl+crosspobe</strong></p><p> 分图和总图的切换：ctrl+上下箭头<br> 测量距离：ctrl+M<br>放弃上一步操作：Backspace键</p><p><strong>一、PCB中常用快捷键</strong></p><ul><li>R+L 输出PCB中所有网络的布线长度</li><li>Ctrl+左键点击对正在布的线完成自动布线连接</li><li>M+G 可更改铜的形状;</li><li>按P+T在布线状态下，按Shift+A可直接进行蛇线走线</li><li>T+R对已布完的线进行蛇线布线</li><li>E++M+C点击空白出可迅速找到PCB上想要的元件</li><li>Backspace 撤销正在布线的上一步操作</li><li>* 切换布线层，可在布线过程中放置过孔</li><li>Ctrl+Shift 切换层并放置过孔</li><li>F8/E+O+S设置圆心点</li><li>M+I 翻转选中的元件</li><li>P+T 布线</li><li>T+E 补泪滴</li><li>P+G 铺铜</li><li>S+Y 单层选择线</li><li>E+B 选择进行复制</li></ul><p><strong>二、以下来源郑振宇老师学生总结：</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9IbGlicTVBN1o2dFBTajlqdTdSajQwbmlibk44Q3NLTk9qRFdYM01HdFBJZWswOFRtaHlqNEF6bkh3VWM3SHg2TkFTM0RCaFNwN3F4aWNSUVZvd0JRYWRpYXcvNjQwP3d4X2ZtdD1qcGVn" alt="640?wx_fmt=jpeg"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9IbGlicTVBN1o2dFBTajlqdTdSajQwbmlibk44Q3NLTk9qNUxhdlhUS09YOHo3UEFlRnVxQjlZQTdkZExmd1RzR3VCRFFLMWNwWWliR2ljVTZ0bmx2VHA0V2cvNjQwP3d4X2ZtdD1qcGVn" alt="640?wx_fmt=jpeg"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9IbGlicTVBN1o2dFBTajlqdTdSajQwbmlibk44Q3NLTk9qVkdpYUJuZ2FKMU9VYXZ5TXZNTFhLSUU5aWJjUE5qbklZd2h4N0RtbUl0c3d5VHl3VkQwcGg0VlEvNjQwP3d4X2ZtdD1qcGVn" alt="640?wx_fmt=jpeg"></p><p><strong>三、BGA 扇出注意事项</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9IbGlicTVBN1o2dFBTajlqdTdSajQwbmlibk44Q3NLTk9qMWdkdDd2OWdPZmNqVDBSc3NsRmpKa2ljaWE5Y01nQTVKOUludWRCcUtpYmtOR0ZRZnV5RFB2RlRnLzY0MD93eF9mbXQ9cG5n" alt="640?wx_fmt=png"></p><p><strong>四、常见的单位换算</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9IbGlicTVBN1o2dFBTajlqdTdSajQwbmlibk44Q3NLTk9qNmlhRjFTaWNBQzVuWEY1OGZpYm5nUGNCelhXelgxOWhFaWN6eUd1S0RoaWNvSkJsMWw2YmhYaWF5Y0RRLzY0MD93eF9mbXQ9cG5n" alt="640?wx_fmt=png"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXovNnptOEZxekU3UncxSFNRUTNpY2RpYWNDcEVpY2dselNUWUpBcmdqdnRVbGV3OTNJemlhZTZIcklDeldjV05ZVWZVQzhPWFZFT1Z2b2paZFpTWmliT2w3ZGU4QS82NDA_" alt="640?"></p><p>图文转自<a href="https://blog.csdn.net/woshiyuzhoushizhe/article/details/97000298%EF%BC%8C%E4%BB%85%E4%BE%9B%E5%8F%82%E8%80%83">https://blog.csdn.net/woshiyuzhoushizhe/article/details/97000298，仅供参考</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> AD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远古项目</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      
        <content type="html"><![CDATA[<center>成本很低大约花了不到一百，视频里的是第一代机器，后续还会开发升级版本。</center><span id="more"></span><iframe id="b" class="b video_pc" src="https://xbeibeix.com/api/bilibili/biliplayer/?url=https://www.bilibili.com/video/BV1bZ4y1j76W" frameborder="0" framespacing="0" allowfullscreen="true" width="100%" height="600" controls="controls" quality="high"></video>></iframe>]]></content>
      
      
      <categories>
          
          <category> 视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习历程</title>
      <link href="/posts/ecf03602/"/>
      <url>/posts/ecf03602/</url>
      
        <content type="html"><![CDATA[<h3 id="从前辈那里讨教了一些方法，大致就是下面这些。"><a href="#从前辈那里讨教了一些方法，大致就是下面这些。" class="headerlink" title="从前辈那里讨教了一些方法，大致就是下面这些。"></a><center>从前辈那里讨教了一些方法，大致就是下面这些。</center></h3><span id="more"></span><ul><li><p>1、STM32 Cube MX使用方法</p><p>2、STM32 HAL库使用方法</p><p>3、STM32启动文件理解</p><p>4、时钟系统（时钟树）梳理、systick定时器</p><p>5、GPIO（8种状态）使用</p><p>6、NVIC中断应用</p><p>7、USART串口通信</p><p>8、DMA外设的应用（基于串口）</p><p>9、IIC外设应用</p><p>10、SPI外设应用</p><p>11、ADC 电压采集</p><p>12、TIM定时器</p><p>13、RTC实时时钟</p><p>14、看门狗应用</p><p>15、PWR电源管理</p></li></ul><hr><p>还有就是不要只是看看例程玩一玩，做项目就简单改改代码。要深入了解底层的原理，比如一开始的点灯</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">GPIO_InitTypeDef  GPIO_InitStructure<span class="token punctuation">;</span><span class="token function">RCC_AHB1PeriphClockCmd</span><span class="token punctuation">(</span>RCC_AHB1Periph_GPIOF<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使能GPIOF时钟</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>很多人都知道这个是用来初始化io口用的，但是为什么这么写就不清楚了；</p><p>这时候就要翻一翻官方的手册了，主要有两本一本《STM32中文参考手册》（因为英语不好），还有一本《stm32固件库中文说明》（理由同上）。遇到一些小麻烦可以去这俩本书上查一下，说不定就会有很大收获。</p><hr><p>另外还有很多的企业或者公司或者社区又或者团队都会有一些参考资料，觉得有用的就拿过来用就是了。例如正点原子，野火等</p><p>遇到不会的问题尽量少去东奔西跑的去询问，很多人都很烦这种行为的。要学会思考，学会自己解决问题的技能，这点非常重要。也有很多人是直接百度的，有时候确实能得到一些答案，但是更多的时候还是一堆疑问。（黑人问号.jpg）毕竟百毒的作用还是有限的，这里建议去一些社区或者论坛来寻找解决方案。例如意法半导体官方，那里有很多的资料文献和文件，还有一些大神的解决方案（但是不多）。还有就是csdn，那里的带佬很多，解决方案也很全面，非常建议去那里查找你需要的答案。</p><p>最后朋友，希望我们能够一起进步、共同成长。</p><p>HOPE FOREVER</p><p>Your friend DarkFox</p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
